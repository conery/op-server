{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A REST Server for OptiPass\u2122 The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients like op-client can run on any system, or even in a Docker container. Overview The server has two main roles: It manages tide gate data for one or more projects. Each data set is a collection of CSV files where records describe tide gates and other barriers. The files also have the information OptiPass needs: the cost to repair or replace a barrier, the upstream habitat impacted by a barrier, and the potential benefit of improving a barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers and short descriptions of potential benefits. The complete data set for the Oregon Coast, for example, describes more than 1000 barriers and is about 350KB in size. A client that uses this data just needs to send the server about 100 bytes of barrier names and optimization goals. Example To interact with an OptiPass server simply send it an HTML GET request. Suppose there is a hypothetical server running at tidegates-r-us.org . A request is a URL that contains the server name and a command that specifies what we want the server to do: http://tidegates-r-us.org/X where X is the command name. For example, the projects command asks the server to send a list of all the data sets it manages. To see what projects are managed by our hypothetical server we would start a terminal session and type a shell command that uses curl , a very simple web browser that sends a request to a server and prints the response: $ curl http://tidegates-r-us.org/projects ['demo','oregon'] This output tells us our hypothetical server has data sets for the demo project (based on sample data in the OptiPass manual) and the Oregon Coast data set. To run OptiPass, the command name is optipass . The URL is a bit more complicated since we have to include options that specify region names, budget levels: $ curl http://tidegates-r-us.org/optipass/oregon?regions=Coos&regions=Umpqua&... {\"summary\":\",budget,habitat,gates...\"} The server will build an input file for OptiPass using barriers from the regions named in the request. It will use other arguments in the request to figure out the budget levels and other information and then run OptiPass once for each budget. After the last run the data in the output files is collected into tables which are then sent back to the client. The output above shows the first few column names in the summary table. Implementation The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : documentation (which you are reading now) static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in the Modules section. The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules. Deployment Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation and Configuration ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory (OptiPass is not included with the repository). add their data files to the static folder open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"A REST Server for OptiPass\u2122"},{"location":"#a-rest-server-for-optipasstm","text":"The Migratory Fish Passage Optimization Tool (OptiPass), is an application developed by Jesse O'Hanley at Ecotelligence\u00ae LLC . The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients like op-client can run on any system, or even in a Docker container.","title":"A REST Server for OptiPass\u2122"},{"location":"#overview","text":"The server has two main roles: It manages tide gate data for one or more projects. Each data set is a collection of CSV files where records describe tide gates and other barriers. The files also have the information OptiPass needs: the cost to repair or replace a barrier, the upstream habitat impacted by a barrier, and the potential benefit of improving a barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers and short descriptions of potential benefits. The complete data set for the Oregon Coast, for example, describes more than 1000 barriers and is about 350KB in size. A client that uses this data just needs to send the server about 100 bytes of barrier names and optimization goals.","title":"Overview"},{"location":"#example","text":"To interact with an OptiPass server simply send it an HTML GET request. Suppose there is a hypothetical server running at tidegates-r-us.org . A request is a URL that contains the server name and a command that specifies what we want the server to do: http://tidegates-r-us.org/X where X is the command name. For example, the projects command asks the server to send a list of all the data sets it manages. To see what projects are managed by our hypothetical server we would start a terminal session and type a shell command that uses curl , a very simple web browser that sends a request to a server and prints the response: $ curl http://tidegates-r-us.org/projects ['demo','oregon'] This output tells us our hypothetical server has data sets for the demo project (based on sample data in the OptiPass manual) and the Oregon Coast data set. To run OptiPass, the command name is optipass . The URL is a bit more complicated since we have to include options that specify region names, budget levels: $ curl http://tidegates-r-us.org/optipass/oregon?regions=Coos&regions=Umpqua&... {\"summary\":\",budget,habitat,gates...\"} The server will build an input file for OptiPass using barriers from the regions named in the request. It will use other arguments in the request to figure out the budget levels and other information and then run OptiPass once for each budget. After the last run the data in the output files is collected into tables which are then sent back to the client. The output above shows the first few column names in the summary table.","title":"Example"},{"location":"#implementation","text":"The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : documentation (which you are reading now) static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in the Modules section. The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules.","title":"Implementation"},{"location":"#deployment","text":"Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation and Configuration ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory (OptiPass is not included with the repository). add their data files to the static folder open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"Deployment"},{"location":"api/","text":"API Once a server is set up and running, we can retrieve data by sending it an HTTP request. The general format of a request URL is http://<server>/<command>/<args> For example, if a server is running at tidegates-r-us.org and you want to retrieve target descriptions for the demo project, send it the \"targets\" command with the project name as an argument: http://tidegates.org-r-us/targets/demo The server will respond with a dictionary (in JSON format) that has the project name and a string that can be converted into a Pandas dataframe. In the examples below we'll assume the server has been started on the local machine and is listening on port 8000 (the default). To launch the server, cd to the project directory and type $ uvicorn app.main:app Then to test a command just type its URL in a curl command: $ curl http://localhost:8000/targets/demo {\"project\":\"demo\",\"targets\":\"abbrev,long,short,label,infra\\nT1,Target 1,Targ1,Target 1 (km),False\\nT2,Target 2,Targ2,Target 2 (km),False\",\"layout\":\"T1 T2\"} projects The projects command returns a list of names of projects configured on the server. Example: $ curl http://localhost:8000/projects [\"demo\",\"oregon\"] barriers/P The barriers command takes one argument, the name of a project. It returns a dictionary that has the project name and a string that can be loaded into a Pandas dataframe. Example: $ curl http://localhost:8000/barriers/demo {\"project\":\"demo\",\"barriers\":\"ID,region,DSID,name,cost,X,Y,NPROJ,comment\\nA,Trident,NA,,250000,330,202,1,\\nB,Red Fork,A,,120000,235,230,1,\\nC,Red Fork,B,,70000,148,220,1,\\nD,Trident,A,,NA,195,335,0,\\nE,Trident,D,,100000,100,440,1,\\nF,Trident,D,,50000,125,450,1,\"}% Here is example of how a client can convert the CSV string into a dataframe: req = f'{server}/barriers/{project}' resp = requests.get(req) if resp.status_code != 200: raise OPServerError(resp) buf = StringIO(resp.json()['barriers']) df = pd.read_csv(buf) A Note About Passability Values The table returned by the barriers command is from the barriers.csv file in the static folder for the project. The passability data in passability.csv is not returned, assuming most clients just need the names and basic information about barriers and targets. targets/P The targets command takes one argument, the name of a project. It returns a dictionary with three entries: the target name a CSV string that can be converted into the target table ( i.e. the contents of the targets.csv file for the project) a text string with the suggested layout for displaying target names in a GUI Example: $ curl http://localhost:8000/targets/demo {\"project\":\"demo\",\"targets\":\"abbrev,long,short,label,infra\\nT1,Target 1,Targ1,Target 1 (km),False\\nT2,Target 2,Targ2,Target 2 (km),False\",\"layout\":\"T1 T2\"}% colnames/P If a project has more than one way of connecting target names to benefit values a server allows a user to put more than one mapping file in the static folder. An example of where this feature is used is in the Oregon coast data. That data set has two differents sets of habitat values for infrastructure targets, some defined for current climate values and a second set that assume temperatures rise and more land is inundated at high tide. That project has two column name mapping files, one named current.csv and one named future.csv . The colnames command returns a dictionary that tells a client whether or not a project has alternative column name mappings. The dictionary has two entries: a name field and a files field with a list of file names. The dictionary returned for the Oregon coast project looks like this: { 'name': 'climate', 'files': ['current.csv', 'future'csv] } This allows the GUI managed by the client to create a menu or a switch labled \"climate\" with two alternatives, one for \"current\" and one for \"future\". The demo project has only one mapping, so the dictionary has None for the name and a single file name in the list: $ curl http://localhost:8000/colnames/demo {\"name\":null,\"files\":[\"colnames.csv\"]}% One of these mapping names -- current , future , or simply colnames -- must be passed to the command that runs OptiPass so it knows which passability values to use. mapinfo/P The mapinfo command retuns a dictionary that tells the client how to display a map in the GUI. There are two kinds of maps. The demo project uses a static map where the map is an image in PNG format. The dictionary returned by the mapinfo command has the necessary information to diplay the map: \"mapinfo\": { \"map_type\": \"StaticMap\", \"map_file\": \"Riverlands.png\", \"map_title\": \"The Riverlands\", \"map_tools\": [\"hover\"] } The PNG image is also stored on the server; to fetch the map the client sends a map command, described below. The other kind of map is a tiled map . For this type of map the client connects to a GIS server to create the map. The Oregon project uses a tiled server, and this is the value passed back to the client that tells it how to display that map: \"mapinfo\": { \"map_type\": \"TiledMap\", \"map_title\": \"Oregon Coast\", \"map_tools\": [\"pan\",\"wheel_zoom\",\"hover\",\"reset\"] } The client uses the mapinfo structures to draw a map in its GUI. When the user clicks a region name, the locations of barriers in that regions are displayed on the map. Those locations are found in the barrier file, in the columns named X and Y . When a project has a static map, the coordinates are locations (in pixels) on the PNG file. For a tiled map, the locations are latitude and longitude; the client passes them to the tile server to fetch the geographic region for the barriers. map/P/F The map command returns a PNG image to the client. The arguments are the project name and the name of the image file (which the client learned from an earlier mapinfo request). For example, this is the request a client would send if it's displaying the demo data: http://localhost:8000/map/demo/Riverlands.png html/P/F The html command returns the contents of an HTML file. The client needs to know the name of the file in advance. For example, both the demo project and the Oregon project have a help page that explains how to use the GUI for that project. To get the instructions, the client would send a request with the project name, e.g. http://localhost:8000/html/demo/welcome.html optipass/P The optipass command is a request to run OptiPass. The URL for this command is more complicated than the others. The project name is specified right after the command name, but after that it expects a series of query parameters . Query parameters appear at the end of the URL, after a question mark. The format for each parameter is a name, an equal sign, and a value. When there is more than one parameter the name-value pairs are separated by an ampersand. Here is a partial example, a request to run OptiPass using the demo project, a target named T1, and barriers from the region named Red Fork: http://localhost:8000/optipass/demo?targets=T1&regions=Red+Fork Note that the project name is specified the same way as it is in the other commands, before the question mark (it's a path parameter ). Note also there are no spaces in the URL. The space in the name \"Red Fork\" is converted to a plus sign. A parameter can appear more than once. The server will collect all the values and put them in a list, in the order they appear in the URL. To run OptiPass with two targets, T1 and T2, the URL would be http://localhost:8000/optipass/demo?targets=T1&targets=T2&... The final URL is going to be very complicated, but fortunately the queries can be generated automatically, for example using a Python library named Requests (which is used by op-client ). The complete list of parameters for the optipass command are shown in the table below. If the \"Value\" colum has \"list\" it means the argument can be specified multiple times and all values will be collected into a list. Argument Value Required? Notes project string yes project name (a path parameter) regions list of strings yes region names as they appear in the barrier file targets list of strings yes 2-letter target IDs budgets list of three integers yes starting budget, increment, and count weights list of integers no if used there must be one for each target mapping string no column name file, e.g. current or future tempdir string no directory with existing results (used in testing) Note that the server that handles this request must be running on a Windows system with OptiPass installed (but see the note about testing, below). This request will run OptiPass with data from the demo project, with a single budget of $400,000, using all the gates and both targets, with weight 3 for T1 and weight 1 for T2: > curl 'http://localhost/op/optipass/demo?regions=Trident&regions=Red+Fork&budgets=400000&budgets=0&budgets=1&targets=T1&targets=T2&weights=3&weights=1' The result returned from the server will be a dictionary containing two tables (in the form of CSV files). The first has one row for each budget, and shows which gates were selected and the potential benefit. The second has one row for each gate. The request in the example above is the same one used for Example 4 in the OptiPass manual. The output should agree with the table in Box 11.","title":"API"},{"location":"api/#api","text":"Once a server is set up and running, we can retrieve data by sending it an HTTP request. The general format of a request URL is http://<server>/<command>/<args> For example, if a server is running at tidegates-r-us.org and you want to retrieve target descriptions for the demo project, send it the \"targets\" command with the project name as an argument: http://tidegates.org-r-us/targets/demo The server will respond with a dictionary (in JSON format) that has the project name and a string that can be converted into a Pandas dataframe. In the examples below we'll assume the server has been started on the local machine and is listening on port 8000 (the default). To launch the server, cd to the project directory and type $ uvicorn app.main:app Then to test a command just type its URL in a curl command: $ curl http://localhost:8000/targets/demo {\"project\":\"demo\",\"targets\":\"abbrev,long,short,label,infra\\nT1,Target 1,Targ1,Target 1 (km),False\\nT2,Target 2,Targ2,Target 2 (km),False\",\"layout\":\"T1 T2\"}","title":"API"},{"location":"api/#projects","text":"The projects command returns a list of names of projects configured on the server. Example: $ curl http://localhost:8000/projects [\"demo\",\"oregon\"]","title":"projects"},{"location":"api/#barriersp","text":"The barriers command takes one argument, the name of a project. It returns a dictionary that has the project name and a string that can be loaded into a Pandas dataframe. Example: $ curl http://localhost:8000/barriers/demo {\"project\":\"demo\",\"barriers\":\"ID,region,DSID,name,cost,X,Y,NPROJ,comment\\nA,Trident,NA,,250000,330,202,1,\\nB,Red Fork,A,,120000,235,230,1,\\nC,Red Fork,B,,70000,148,220,1,\\nD,Trident,A,,NA,195,335,0,\\nE,Trident,D,,100000,100,440,1,\\nF,Trident,D,,50000,125,450,1,\"}% Here is example of how a client can convert the CSV string into a dataframe: req = f'{server}/barriers/{project}' resp = requests.get(req) if resp.status_code != 200: raise OPServerError(resp) buf = StringIO(resp.json()['barriers']) df = pd.read_csv(buf)","title":"barriers/P"},{"location":"api/#a-note-about-passability-values","text":"The table returned by the barriers command is from the barriers.csv file in the static folder for the project. The passability data in passability.csv is not returned, assuming most clients just need the names and basic information about barriers and targets.","title":"A Note About Passability Values"},{"location":"api/#targetsp","text":"The targets command takes one argument, the name of a project. It returns a dictionary with three entries: the target name a CSV string that can be converted into the target table ( i.e. the contents of the targets.csv file for the project) a text string with the suggested layout for displaying target names in a GUI Example: $ curl http://localhost:8000/targets/demo {\"project\":\"demo\",\"targets\":\"abbrev,long,short,label,infra\\nT1,Target 1,Targ1,Target 1 (km),False\\nT2,Target 2,Targ2,Target 2 (km),False\",\"layout\":\"T1 T2\"}%","title":"targets/P"},{"location":"api/#colnamesp","text":"If a project has more than one way of connecting target names to benefit values a server allows a user to put more than one mapping file in the static folder. An example of where this feature is used is in the Oregon coast data. That data set has two differents sets of habitat values for infrastructure targets, some defined for current climate values and a second set that assume temperatures rise and more land is inundated at high tide. That project has two column name mapping files, one named current.csv and one named future.csv . The colnames command returns a dictionary that tells a client whether or not a project has alternative column name mappings. The dictionary has two entries: a name field and a files field with a list of file names. The dictionary returned for the Oregon coast project looks like this: { 'name': 'climate', 'files': ['current.csv', 'future'csv] } This allows the GUI managed by the client to create a menu or a switch labled \"climate\" with two alternatives, one for \"current\" and one for \"future\". The demo project has only one mapping, so the dictionary has None for the name and a single file name in the list: $ curl http://localhost:8000/colnames/demo {\"name\":null,\"files\":[\"colnames.csv\"]}% One of these mapping names -- current , future , or simply colnames -- must be passed to the command that runs OptiPass so it knows which passability values to use.","title":"colnames/P"},{"location":"api/#mapinfop","text":"The mapinfo command retuns a dictionary that tells the client how to display a map in the GUI. There are two kinds of maps. The demo project uses a static map where the map is an image in PNG format. The dictionary returned by the mapinfo command has the necessary information to diplay the map: \"mapinfo\": { \"map_type\": \"StaticMap\", \"map_file\": \"Riverlands.png\", \"map_title\": \"The Riverlands\", \"map_tools\": [\"hover\"] } The PNG image is also stored on the server; to fetch the map the client sends a map command, described below. The other kind of map is a tiled map . For this type of map the client connects to a GIS server to create the map. The Oregon project uses a tiled server, and this is the value passed back to the client that tells it how to display that map: \"mapinfo\": { \"map_type\": \"TiledMap\", \"map_title\": \"Oregon Coast\", \"map_tools\": [\"pan\",\"wheel_zoom\",\"hover\",\"reset\"] } The client uses the mapinfo structures to draw a map in its GUI. When the user clicks a region name, the locations of barriers in that regions are displayed on the map. Those locations are found in the barrier file, in the columns named X and Y . When a project has a static map, the coordinates are locations (in pixels) on the PNG file. For a tiled map, the locations are latitude and longitude; the client passes them to the tile server to fetch the geographic region for the barriers.","title":"mapinfo/P"},{"location":"api/#mappf","text":"The map command returns a PNG image to the client. The arguments are the project name and the name of the image file (which the client learned from an earlier mapinfo request). For example, this is the request a client would send if it's displaying the demo data: http://localhost:8000/map/demo/Riverlands.png","title":"map/P/F"},{"location":"api/#htmlpf","text":"The html command returns the contents of an HTML file. The client needs to know the name of the file in advance. For example, both the demo project and the Oregon project have a help page that explains how to use the GUI for that project. To get the instructions, the client would send a request with the project name, e.g. http://localhost:8000/html/demo/welcome.html","title":"html/P/F"},{"location":"api/#optipassp","text":"The optipass command is a request to run OptiPass. The URL for this command is more complicated than the others. The project name is specified right after the command name, but after that it expects a series of query parameters . Query parameters appear at the end of the URL, after a question mark. The format for each parameter is a name, an equal sign, and a value. When there is more than one parameter the name-value pairs are separated by an ampersand. Here is a partial example, a request to run OptiPass using the demo project, a target named T1, and barriers from the region named Red Fork: http://localhost:8000/optipass/demo?targets=T1&regions=Red+Fork Note that the project name is specified the same way as it is in the other commands, before the question mark (it's a path parameter ). Note also there are no spaces in the URL. The space in the name \"Red Fork\" is converted to a plus sign. A parameter can appear more than once. The server will collect all the values and put them in a list, in the order they appear in the URL. To run OptiPass with two targets, T1 and T2, the URL would be http://localhost:8000/optipass/demo?targets=T1&targets=T2&... The final URL is going to be very complicated, but fortunately the queries can be generated automatically, for example using a Python library named Requests (which is used by op-client ). The complete list of parameters for the optipass command are shown in the table below. If the \"Value\" colum has \"list\" it means the argument can be specified multiple times and all values will be collected into a list. Argument Value Required? Notes project string yes project name (a path parameter) regions list of strings yes region names as they appear in the barrier file targets list of strings yes 2-letter target IDs budgets list of three integers yes starting budget, increment, and count weights list of integers no if used there must be one for each target mapping string no column name file, e.g. current or future tempdir string no directory with existing results (used in testing) Note that the server that handles this request must be running on a Windows system with OptiPass installed (but see the note about testing, below). This request will run OptiPass with data from the demo project, with a single budget of $400,000, using all the gates and both targets, with weight 3 for T1 and weight 1 for T2: > curl 'http://localhost/op/optipass/demo?regions=Trident&regions=Red+Fork&budgets=400000&budgets=0&budgets=1&targets=T1&targets=T2&weights=3&weights=1' The result returned from the server will be a dictionary containing two tables (in the form of CSV files). The first has one row for each budget, and shows which gates were selected and the potential benefit. The second has one row for each gate. The request in the example above is the same one used for Example 4 in the OptiPass manual. The output should agree with the table in Box 11.","title":"optipass/P"},{"location":"api/#_1","text":"","title":""},{"location":"data/","text":"Data Models The three main types of data managed by the server are barriers , targets , and passability . Barriers A barrier can be a tide gate, culvert, or any other impediment to fish migration. Barrier data is kept in tables that have one row for each barrier. The columns of the table describe the key attributes: a unique ID a region name, which is typically the name of an estuary or river system the ID of the barrier immediately downstream; we use the acronym DSID (this is left empty if the barrier is the at the mouth of the river) the estimated cost to repair the barrier the barrier's location , typically represented by latitude and longitude. There may be additional data that can be used by a client, for example a barrier type (tide gate, culvert, etc ) or a descriptive name (\"Jones Farm\"). Targets Stakeholders can have several different goals for a restoration project. They may want to improve fish passage, or protect farmland or other infrastructure. Within these general categories are more specific goals. Different species of fish might find it easier to get past a barrier. Tide gates set up to protect infrastructure might have different capabilities for farms, roads, or buildings. Descriptions of targets are also kept in tables, with one row for each target. The columns of this table describe the attributes of each target: the target name, typically the name of fish species (\"Coho Salmon\") or a type of infrastructure (\"Roads & Railroads\") a unique two-letter identifier, often an abbreviation of the target name (\"CO\", \"RR\") a shortened name used in output tables (\"Coho\", \"Roads\") a descriptive name used to label plots; this name should include units (\"Potential Habitat (miles)\" or \"Roads Protected (miles)\") Passability When OptiPass is searching for the most effective combination of barriers to replace for a given amount of money it needs to know what the potential gains are for replacing a barrier. This is where the concept of passability is used. Every barrier has some effect on each target. The relevant information is the habtitat immediately upstream from the barrier, up to the next barrier if there is one, or to the end of the river the current level of passability (abbreviated as prepass ), represented by a number between 0 (completely blocked) and 1 (totally passable) the potential level of passability if the barrier is repaired or replaced (abbreviated postpass ), also a number between 0 and 1 For fish targets habitat is the number of river miles above the barrier. This can be different for each species, e.g. a river can be a better food source or better spawning grounds for different species. For infrastructure targets we still use the term \"habitat\" even though the meaning of this attribute will not be the same. For buildings the \"habitat\" value is the number of buildings protected, for farmland it would be the number of acres, and so on. In order to do calculations that combine different types of targets the tables also include a scaled habitat value, where the different types of habitat numbers have been converted to a common scale. The scaled values are given to OptiPass so it can compare targets of all types. The original unscaled values are used in plots and output tables. Projects The data managed by the server can be organized into separate projects. The server comes with a demo project that has the example data from the OptiPass User Manual . Users can add their own data for actual river systems in one or more additional projects. For example, a project named oregon has descriptions of over 1000 tide gates in 10 river systems on the Oregon coast. The tables for the Oregon project are used in some examples but are not included in the GitHub repo. Projects not only include the barrier data but also formatting information used by a client. This includes geographic coordinates so barriers can be plotted on a map and various descriptions in HTML files that can be displayed by a graphical user interface. Detailed instructions for how to format barrier files, target descriptions, passability tables, and project descriptions can be found in Installation and Configuration . Example The small river system used as an example in the OptiPass user manual has six barriers, named A through F . A is at the mouth of the river, and the rest are all upstream from A : At each barrier p\u2070 is the pre-mitigation (prepass) value, c is the cost to repair the barrier, and h is the habitat (in river kilometers) directly upriver from the barrier. In this example barrier D is a natural barrier that cannot be replaced, so there is no cost associated with this node. In order to show how barriers can be organized into regions and displayed in a GUI we put the barriers on an imaginary map and assigned them to two different rivers. The barrier file has these columns (plus a few more not shown here): ID region DSID cost X Y A Trident NA 250000 330 202 B Red Fork A 120000 235 230 C Red Fork B 70000 148 220 D Trident A NA 195 335 E Trident D 100000 100 440 F Trident D 50000 125 450 The figure above shows values for only one target. Later in the manual there is an example that has a second target. We put the data for both targets in a passability table: ID HAB1 PRE1 POST1 HAB2 PRE2 POST2 A 2.1 0.4 1.0 1.68 0.6 1.0 B 0.9 0.0 1.0 0.72 0.0 1.0 C 4.3 0.3 1.0 3.44 0.45 1.0 D 1.7 0.5 NA 1.36 0.75 NA E 1.2 0.2 1.0 0.96 0.3 1.0 F 0.5 0.1 1.0 0.40 0.15 1.0 The barrier table and passability table have the same rows and row labels, so all this information could go in a single table. We split them into two tables to make it easier to keep track of passability values. The two targets in the manual are referred to simply as \"T1\" and \"T2\", but we put them in a table to show how longer descriptions are represented: abbrev long short label T1 Target 1 Targ1 Target 1 (km) T2 Target 2 Targ2 Target 2 (km) The final piece of information the server needs is a table that connects the targets (described in the target table above) with their passability values (names of columns in the passability table): abbrev habitat prepass postpass unscaled T1 HAB1 PRE1 POST1 HAB1 T2 HAB2 PRE2 POST2 HAB2 This tells the server to find data for target T1 in columns HAB1 , PRE1 , and POST1 , and the data for target T2 are in HAB2 , PRE2 , and POST2 . Since the demo project does not have scaled data (habitat for both targets is defined in terms of river miles) the name in the unscaled column is the same as the name in the habitat column. For a data set with scaled habitats there would be four columns for each target in the passability table and the column name table would refer to all four names.","title":"Data Models"},{"location":"data/#data-models","text":"The three main types of data managed by the server are barriers , targets , and passability .","title":"Data Models"},{"location":"data/#barriers","text":"A barrier can be a tide gate, culvert, or any other impediment to fish migration. Barrier data is kept in tables that have one row for each barrier. The columns of the table describe the key attributes: a unique ID a region name, which is typically the name of an estuary or river system the ID of the barrier immediately downstream; we use the acronym DSID (this is left empty if the barrier is the at the mouth of the river) the estimated cost to repair the barrier the barrier's location , typically represented by latitude and longitude. There may be additional data that can be used by a client, for example a barrier type (tide gate, culvert, etc ) or a descriptive name (\"Jones Farm\").","title":"Barriers"},{"location":"data/#targets","text":"Stakeholders can have several different goals for a restoration project. They may want to improve fish passage, or protect farmland or other infrastructure. Within these general categories are more specific goals. Different species of fish might find it easier to get past a barrier. Tide gates set up to protect infrastructure might have different capabilities for farms, roads, or buildings. Descriptions of targets are also kept in tables, with one row for each target. The columns of this table describe the attributes of each target: the target name, typically the name of fish species (\"Coho Salmon\") or a type of infrastructure (\"Roads & Railroads\") a unique two-letter identifier, often an abbreviation of the target name (\"CO\", \"RR\") a shortened name used in output tables (\"Coho\", \"Roads\") a descriptive name used to label plots; this name should include units (\"Potential Habitat (miles)\" or \"Roads Protected (miles)\")","title":"Targets"},{"location":"data/#passability","text":"When OptiPass is searching for the most effective combination of barriers to replace for a given amount of money it needs to know what the potential gains are for replacing a barrier. This is where the concept of passability is used. Every barrier has some effect on each target. The relevant information is the habtitat immediately upstream from the barrier, up to the next barrier if there is one, or to the end of the river the current level of passability (abbreviated as prepass ), represented by a number between 0 (completely blocked) and 1 (totally passable) the potential level of passability if the barrier is repaired or replaced (abbreviated postpass ), also a number between 0 and 1 For fish targets habitat is the number of river miles above the barrier. This can be different for each species, e.g. a river can be a better food source or better spawning grounds for different species. For infrastructure targets we still use the term \"habitat\" even though the meaning of this attribute will not be the same. For buildings the \"habitat\" value is the number of buildings protected, for farmland it would be the number of acres, and so on. In order to do calculations that combine different types of targets the tables also include a scaled habitat value, where the different types of habitat numbers have been converted to a common scale. The scaled values are given to OptiPass so it can compare targets of all types. The original unscaled values are used in plots and output tables.","title":"Passability"},{"location":"data/#projects","text":"The data managed by the server can be organized into separate projects. The server comes with a demo project that has the example data from the OptiPass User Manual . Users can add their own data for actual river systems in one or more additional projects. For example, a project named oregon has descriptions of over 1000 tide gates in 10 river systems on the Oregon coast. The tables for the Oregon project are used in some examples but are not included in the GitHub repo. Projects not only include the barrier data but also formatting information used by a client. This includes geographic coordinates so barriers can be plotted on a map and various descriptions in HTML files that can be displayed by a graphical user interface. Detailed instructions for how to format barrier files, target descriptions, passability tables, and project descriptions can be found in Installation and Configuration .","title":"Projects"},{"location":"data/#example","text":"The small river system used as an example in the OptiPass user manual has six barriers, named A through F . A is at the mouth of the river, and the rest are all upstream from A : At each barrier p\u2070 is the pre-mitigation (prepass) value, c is the cost to repair the barrier, and h is the habitat (in river kilometers) directly upriver from the barrier. In this example barrier D is a natural barrier that cannot be replaced, so there is no cost associated with this node. In order to show how barriers can be organized into regions and displayed in a GUI we put the barriers on an imaginary map and assigned them to two different rivers. The barrier file has these columns (plus a few more not shown here): ID region DSID cost X Y A Trident NA 250000 330 202 B Red Fork A 120000 235 230 C Red Fork B 70000 148 220 D Trident A NA 195 335 E Trident D 100000 100 440 F Trident D 50000 125 450 The figure above shows values for only one target. Later in the manual there is an example that has a second target. We put the data for both targets in a passability table: ID HAB1 PRE1 POST1 HAB2 PRE2 POST2 A 2.1 0.4 1.0 1.68 0.6 1.0 B 0.9 0.0 1.0 0.72 0.0 1.0 C 4.3 0.3 1.0 3.44 0.45 1.0 D 1.7 0.5 NA 1.36 0.75 NA E 1.2 0.2 1.0 0.96 0.3 1.0 F 0.5 0.1 1.0 0.40 0.15 1.0 The barrier table and passability table have the same rows and row labels, so all this information could go in a single table. We split them into two tables to make it easier to keep track of passability values. The two targets in the manual are referred to simply as \"T1\" and \"T2\", but we put them in a table to show how longer descriptions are represented: abbrev long short label T1 Target 1 Targ1 Target 1 (km) T2 Target 2 Targ2 Target 2 (km) The final piece of information the server needs is a table that connects the targets (described in the target table above) with their passability values (names of columns in the passability table): abbrev habitat prepass postpass unscaled T1 HAB1 PRE1 POST1 HAB1 T2 HAB2 PRE2 POST2 HAB2 This tells the server to find data for target T1 in columns HAB1 , PRE1 , and POST1 , and the data for target T2 are in HAB2 , PRE2 , and POST2 . Since the demo project does not have scaled data (habitat for both targets is defined in terms of river miles) the name in the unscaled column is the same as the name in the habitat column. For a data set with scaled habitats there would be four columns for each target in the passability table and the column name table would refer to all four names.","title":"Example"},{"location":"install/","text":"Installation and Configuration Set Up a Windows Server Since OptiPass is a Windows application it must be run from a Windows system. The easiest way to set up a new server is to create a Windows VM at Amazon Web Services or any cloud based hosting service. The OptiPass Server is written entirely in Python. It uses a library named FastAPI to create a RESTful web service. When you start the program FastAPI will start up a web server (named Uvicorn) and have it listen for connections, by default using port 8000. You could then open up that port on your system so the OptiPass Client (or any other application) could connect to your server. However, the simple web server that comes with FasstAPI is very rudimentary. Instead, the developers of FastAPI recommend installing an \"industrial strength\" server like Nginx or Apache and connecting to Uvicorn with a reverse proxy. One of the advantages of Nginx or Apache is that they can handle encrypted connections using HTTPS. Install the Python Modules Install Python and Pip (the Package Installer for Python). You can use any version of Python later than 3.11.1. The easiest way to install the server is to tell Pip to get the code from GitHub. Start a Powershell window, create a directory where you want to install the code, and then type this command from that directory: > python -m pip install https://github.com/conery/op-server.git As an alternative, clone the repo: > gh repo clone conery/op-server Then cd to the new repo and type this command (note the period at the end of the line): > python -m pip install . Install OptiPass Make a new folder named bin in the repo. Obtain a copy of .exe file for OptiPass from EcoTelligence LLC or another source. Make sure it's the command line executable, not the GUI version. It should be named OptiPassMain.exe . Put this file in the bin folder. Add Data Files to the static Directory The server organizes data according to projects . Each project can have its own barrier data, restoration targets, and so on. All of this data is located in the static folder in the repo. Inside that folder are six subfolders: ./static \u251c\u2500\u2500 barriers \u251c\u2500\u2500 colnames \u251c\u2500\u2500 html \u251c\u2500\u2500 images \u251c\u2500\u2500 maps \u2514\u2500\u2500 targets Inside these folders are further subfolders for the data for each project, where the name of the project matches the name of the subfolder. For example, if a server has data for two projects, named demo and oregon the folders would look like this: ./static \u251c\u2500\u2500 barriers \u2502 \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 oregon \u251c\u2500\u2500 colnames \u2502 \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 oregon ... The files for the demo project are useful starting points for creating your own project data. To add your own content, create a new folder in each area, based on the name of your project. Inside that folder add new CSV or HTML files, following the guidelines in this section. barriers Directory There should be two CSV files to describe the barriers in a project: barriers/ \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 barriers.csv \u2502 \u2514\u2500\u2500 passability.csv Both of these files should have one line for each barrier: barriers.csv will have the basic information about each barrier. passability.csv will have the habitat, prepass, and postpass values for each target for each barrier. barriers.csv The names of the columns in barriers.csv should match the names shown in the table below. column name description note ID a unique ID, composed of letters and digits region geographic region name, typically the name of a river DSID ID of barrier immediately downstream (1) name more descriptive barrier name (can be left blank) cost cost to repair or replace the barrier (2) X horizontal coordinate of the barrier on the project's map (3) Y vertical coordinate of the barrier on the project's map (3) NPROJ a 1 or a 0 to indicate whether or not to include the barrier (4) comment an optional comment Put \"NA\" in the DSID column if a barrier does not have a downstream neighbor. Otherwise the name in this column must match an ID in another row. The units in the cost column should be number of dollars. The OptiPass manual uses \"thousands of dollars\", e.g. it would put 100 in the table to mean $100,000, but in this data set use the full amount and write 100000 (without commas). The coordinate values depend on the type of map. For static maps use pixels, where (0,0) is the lower left. For tiled maps use latitude and longitude. Put a 0 in the NPROJ column if a barrier cannot be repaired and should not be included in the set analyzed by OptiPass. passability.csv There should be one line in passability.csv for each line in barriers.csv . The first column in this file should also be named ID , and the names in this column must match the names in barriers.csv . Following the ID column there should be three columns for each target (four if targets use scaled habitat values). The names of the columns are arbitrary but should be based on target names (the names will be used in other tables and need to be recognizable). For example, the two targets in the demo project are named T1 and T2, so natural names for the columns are HAB1, PRE1, and POST1 for the habitat, prepass, and postpass values of target T1, and HAB2, PRE2, and POST2 for the values of target T2. Here are the first few lines of passability.csv for the demo project: ID HAB1 PRE1 POST1 HAB2 PRE2 POST2 A 2.1 0.4 1.0 1.68 0.6 1.0 B 0.9 0.0 1.0 0.72 0.0 1.0 ... ... ... ... ... ... ... If a project has scaled habitat values include a fourth column for each target and give it an appropriate name. For example, if the demo project had scaled values, the extra columns might be called sHAB1 and sHAB2. A passability.csv file can be made a bit smaller if two or more columns have the same values. For example, the postpass columns in the demo project (POST1 and POST2) both have 1.0 for in every row, meaning that after repair all the gates are fully functional. In that case, the table can be simplified by dropping one of the columns and renaming ther other one to POST (without a target number). The only requirement is that every name that appears in a mapping file ( colnames.csv , described below) has to appear as a column somewhere in the passability table. colnames Directory The structure of this directory depends on whether a project has more than one set of passability values for targets. This is what the directory looks like on a server that has two projects, one for the demo data and one for the Oregon coast: colnames/ \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 colnames.csv \u2514\u2500\u2500 oregon \u2514\u2500\u2500 climate \u251c\u2500\u2500 current.csv \u2514\u2500\u2500 future.csv The fact that there is only one file in the demo folder means there is only one way to associate target names with passability values, and it's in the file named colnames.csv . The subdirectory under oregon means users will have a choice, named \"climate\" (using the name of the subdirectory), and can pick which set of passability values to use. Regardless of how the directory is structured, all the CSV files have the same information. There will be one row for each target, and the contents will be names of columns from the passability.csv file for the project. Here is the file for the demo project: abbrev habitat prepass postpass unscaled T1 HAB1 PRE1 POST1 HAB1 T2 HAB2 PRE2 POST2 HAB2 The first row says the passability values for target T1 can be found in columns named HAB1, PRE1, and POST1 in the project's passability.csv file. If a project uses scaled habitat values, put the name of the scaled habitat in the habitat column and the name of the original unscaled values in the unscaled column. The demo project does not have scaled habitats, so the name in the unscaled column is just the same as the name in the habitat column. html Directory The html directory has static content the client will display in a GUI. html \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 help.html \u2502 \u2514\u2500\u2500 welcome.html The Welcome tab in the GUI describes a project and gives the overall description of the workflow required to use OptiPass. A Help tab has detailed instructions of how to use each \"widget\" to enter optimization parameters. Each project can tailor the contents of these files to fit their data. maps Directory The maps directory tells a client how to draw the map for the project. This is the maps directory for the demo project: maps \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 Riverlands.png \u2502 \u2514\u2500\u2500 mapinfo.json Every project needs a mapinfo.json file. This is the file for the demo project: { \"map_type\": \"StaticMap\", \"map_file\": \"Riverlands.png\", \"map_title\": \"The Riverlands\", \"map_tools\": [\"hover\"] } The map_type entry can be either StaticMap or TiledMap. A StaticMap is simply a PNG image. If a project has a StaticMap there must also be a map_file entry in the JSON file and a PNG file of that name should also be placed in the maps directory. If the map type is TiledMap the client will connect to a tile server to draw the map. Map coordinates are taken from the barrier file, and the map that appears in the GUI will be big enough to include all barriers. The map_title and map_tools entries are used by the client. The tools are icons drawn at the bottom of the map that allow the user to interact with the map, e.g. to zoom in or move around. The items that can appear in the map_tools list are: hover , which will display the ID and other information about a barrier when the user moves their mouse over a barrier on the map wheel_zoom allows the user to zoom in or out pan allows the user to move the map left/right or up/down reset is a button that restors a map to the original coordinates after panning or zooming targets Directory The targets directory for a project needs two files: targets \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 layout.txt \u2502 \u2514\u2500\u2500 targets.csv The CSV file has entries that describe the restoration targets for the project. The file should have the following columns: column name description abbrev a unique two-letter ID for the target long the full name of the target short a shorter name used in output tables label a name to use in plots, which should include units infra True if the target has multiple colname mappings Here are two examples from the Oregon Coast project (which has more interesting targets than the demo data): abbrev long short label infra CO Coho Streams Coho Habitat Potential (miles) False AG Agriculture Agric Farmland Potentially Protected (acres) True The layout file is used by the client to display the GUI elements that let users select targets. As an example, the Oregon project has ten targets, six for fish species and four for infrastructure. If we want the GUI to arrange them in two columns, with fish targets (which have names CO, CH, ST, ...) in the left column and infrastructure targets (named AG, RR, BL, ...) on the right, the layout file simply lists the names in the order they should be displayed: CO AG CH RR ST BL ...","title":"Installation and Configuration"},{"location":"install/#installation-and-configuration","text":"","title":"Installation and Configuration"},{"location":"install/#set-up-a-windows-server","text":"Since OptiPass is a Windows application it must be run from a Windows system. The easiest way to set up a new server is to create a Windows VM at Amazon Web Services or any cloud based hosting service. The OptiPass Server is written entirely in Python. It uses a library named FastAPI to create a RESTful web service. When you start the program FastAPI will start up a web server (named Uvicorn) and have it listen for connections, by default using port 8000. You could then open up that port on your system so the OptiPass Client (or any other application) could connect to your server. However, the simple web server that comes with FasstAPI is very rudimentary. Instead, the developers of FastAPI recommend installing an \"industrial strength\" server like Nginx or Apache and connecting to Uvicorn with a reverse proxy. One of the advantages of Nginx or Apache is that they can handle encrypted connections using HTTPS.","title":"Set Up a Windows Server"},{"location":"install/#install-the-python-modules","text":"Install Python and Pip (the Package Installer for Python). You can use any version of Python later than 3.11.1. The easiest way to install the server is to tell Pip to get the code from GitHub. Start a Powershell window, create a directory where you want to install the code, and then type this command from that directory: > python -m pip install https://github.com/conery/op-server.git As an alternative, clone the repo: > gh repo clone conery/op-server Then cd to the new repo and type this command (note the period at the end of the line): > python -m pip install .","title":"Install the Python Modules"},{"location":"install/#install-optipass","text":"Make a new folder named bin in the repo. Obtain a copy of .exe file for OptiPass from EcoTelligence LLC or another source. Make sure it's the command line executable, not the GUI version. It should be named OptiPassMain.exe . Put this file in the bin folder.","title":"Install OptiPass"},{"location":"install/#add-data-files-to-the-static-directory","text":"The server organizes data according to projects . Each project can have its own barrier data, restoration targets, and so on. All of this data is located in the static folder in the repo. Inside that folder are six subfolders: ./static \u251c\u2500\u2500 barriers \u251c\u2500\u2500 colnames \u251c\u2500\u2500 html \u251c\u2500\u2500 images \u251c\u2500\u2500 maps \u2514\u2500\u2500 targets Inside these folders are further subfolders for the data for each project, where the name of the project matches the name of the subfolder. For example, if a server has data for two projects, named demo and oregon the folders would look like this: ./static \u251c\u2500\u2500 barriers \u2502 \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 oregon \u251c\u2500\u2500 colnames \u2502 \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 oregon ... The files for the demo project are useful starting points for creating your own project data. To add your own content, create a new folder in each area, based on the name of your project. Inside that folder add new CSV or HTML files, following the guidelines in this section.","title":"Add Data Files to the static Directory"},{"location":"install/#barriers-directory","text":"There should be two CSV files to describe the barriers in a project: barriers/ \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 barriers.csv \u2502 \u2514\u2500\u2500 passability.csv Both of these files should have one line for each barrier: barriers.csv will have the basic information about each barrier. passability.csv will have the habitat, prepass, and postpass values for each target for each barrier.","title":"barriers Directory"},{"location":"install/#barrierscsv","text":"The names of the columns in barriers.csv should match the names shown in the table below. column name description note ID a unique ID, composed of letters and digits region geographic region name, typically the name of a river DSID ID of barrier immediately downstream (1) name more descriptive barrier name (can be left blank) cost cost to repair or replace the barrier (2) X horizontal coordinate of the barrier on the project's map (3) Y vertical coordinate of the barrier on the project's map (3) NPROJ a 1 or a 0 to indicate whether or not to include the barrier (4) comment an optional comment Put \"NA\" in the DSID column if a barrier does not have a downstream neighbor. Otherwise the name in this column must match an ID in another row. The units in the cost column should be number of dollars. The OptiPass manual uses \"thousands of dollars\", e.g. it would put 100 in the table to mean $100,000, but in this data set use the full amount and write 100000 (without commas). The coordinate values depend on the type of map. For static maps use pixels, where (0,0) is the lower left. For tiled maps use latitude and longitude. Put a 0 in the NPROJ column if a barrier cannot be repaired and should not be included in the set analyzed by OptiPass.","title":"barriers.csv"},{"location":"install/#passabilitycsv","text":"There should be one line in passability.csv for each line in barriers.csv . The first column in this file should also be named ID , and the names in this column must match the names in barriers.csv . Following the ID column there should be three columns for each target (four if targets use scaled habitat values). The names of the columns are arbitrary but should be based on target names (the names will be used in other tables and need to be recognizable). For example, the two targets in the demo project are named T1 and T2, so natural names for the columns are HAB1, PRE1, and POST1 for the habitat, prepass, and postpass values of target T1, and HAB2, PRE2, and POST2 for the values of target T2. Here are the first few lines of passability.csv for the demo project: ID HAB1 PRE1 POST1 HAB2 PRE2 POST2 A 2.1 0.4 1.0 1.68 0.6 1.0 B 0.9 0.0 1.0 0.72 0.0 1.0 ... ... ... ... ... ... ... If a project has scaled habitat values include a fourth column for each target and give it an appropriate name. For example, if the demo project had scaled values, the extra columns might be called sHAB1 and sHAB2. A passability.csv file can be made a bit smaller if two or more columns have the same values. For example, the postpass columns in the demo project (POST1 and POST2) both have 1.0 for in every row, meaning that after repair all the gates are fully functional. In that case, the table can be simplified by dropping one of the columns and renaming ther other one to POST (without a target number). The only requirement is that every name that appears in a mapping file ( colnames.csv , described below) has to appear as a column somewhere in the passability table.","title":"passability.csv"},{"location":"install/#colnames-directory","text":"The structure of this directory depends on whether a project has more than one set of passability values for targets. This is what the directory looks like on a server that has two projects, one for the demo data and one for the Oregon coast: colnames/ \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 colnames.csv \u2514\u2500\u2500 oregon \u2514\u2500\u2500 climate \u251c\u2500\u2500 current.csv \u2514\u2500\u2500 future.csv The fact that there is only one file in the demo folder means there is only one way to associate target names with passability values, and it's in the file named colnames.csv . The subdirectory under oregon means users will have a choice, named \"climate\" (using the name of the subdirectory), and can pick which set of passability values to use. Regardless of how the directory is structured, all the CSV files have the same information. There will be one row for each target, and the contents will be names of columns from the passability.csv file for the project. Here is the file for the demo project: abbrev habitat prepass postpass unscaled T1 HAB1 PRE1 POST1 HAB1 T2 HAB2 PRE2 POST2 HAB2 The first row says the passability values for target T1 can be found in columns named HAB1, PRE1, and POST1 in the project's passability.csv file. If a project uses scaled habitat values, put the name of the scaled habitat in the habitat column and the name of the original unscaled values in the unscaled column. The demo project does not have scaled habitats, so the name in the unscaled column is just the same as the name in the habitat column.","title":"colnames Directory"},{"location":"install/#html-directory","text":"The html directory has static content the client will display in a GUI. html \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 help.html \u2502 \u2514\u2500\u2500 welcome.html The Welcome tab in the GUI describes a project and gives the overall description of the workflow required to use OptiPass. A Help tab has detailed instructions of how to use each \"widget\" to enter optimization parameters. Each project can tailor the contents of these files to fit their data.","title":"html Directory"},{"location":"install/#maps-directory","text":"The maps directory tells a client how to draw the map for the project. This is the maps directory for the demo project: maps \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 Riverlands.png \u2502 \u2514\u2500\u2500 mapinfo.json Every project needs a mapinfo.json file. This is the file for the demo project: { \"map_type\": \"StaticMap\", \"map_file\": \"Riverlands.png\", \"map_title\": \"The Riverlands\", \"map_tools\": [\"hover\"] } The map_type entry can be either StaticMap or TiledMap. A StaticMap is simply a PNG image. If a project has a StaticMap there must also be a map_file entry in the JSON file and a PNG file of that name should also be placed in the maps directory. If the map type is TiledMap the client will connect to a tile server to draw the map. Map coordinates are taken from the barrier file, and the map that appears in the GUI will be big enough to include all barriers. The map_title and map_tools entries are used by the client. The tools are icons drawn at the bottom of the map that allow the user to interact with the map, e.g. to zoom in or move around. The items that can appear in the map_tools list are: hover , which will display the ID and other information about a barrier when the user moves their mouse over a barrier on the map wheel_zoom allows the user to zoom in or out pan allows the user to move the map left/right or up/down reset is a button that restors a map to the original coordinates after panning or zooming","title":"maps Directory"},{"location":"install/#targets-directory","text":"The targets directory for a project needs two files: targets \u251c\u2500\u2500 demo \u2502 \u251c\u2500\u2500 layout.txt \u2502 \u2514\u2500\u2500 targets.csv The CSV file has entries that describe the restoration targets for the project. The file should have the following columns: column name description abbrev a unique two-letter ID for the target long the full name of the target short a shorter name used in output tables label a name to use in plots, which should include units infra True if the target has multiple colname mappings Here are two examples from the Oregon Coast project (which has more interesting targets than the demo data): abbrev long short label infra CO Coho Streams Coho Habitat Potential (miles) False AG Agriculture Agric Farmland Potentially Protected (acres) True The layout file is used by the client to display the GUI elements that let users select targets. As an example, the Oregon project has ten targets, six for fish species and four for infrastructure. If we want the GUI to arrange them in two columns, with fish targets (which have names CO, CH, ST, ...) in the left column and infrastructure targets (named AG, RR, BL, ...) on the right, the layout file simply lists the names in the order they should be displayed: CO AG CH RR ST BL ...","title":"targets Directory"},{"location":"modules/","text":"Modules The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one ( optipass.py ) that provides an abstract interface for running OptiPass. app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py main.py init Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE global MAPS , MAPINFO_FILE global TARGETS , TARGET_FILE , LAYOUT_FILE global COLNAMES , COLNAME_FILE global HTMLDIR , IMAGEDIR MAPS = 'static/maps' MAPINFO_FILE = 'mapinfo.json' BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' LAYOUT_FILE = 'layout.txt' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' HTMLDIR = 'static/html' # IMAGEDIR = 'static/images' global project_names , region_names logging . basicConfig ( level = logging . INFO , style = '{' , format = ' {message} ' , handlers = [ RichHandler ( markup = True , rich_tracebacks = True )], ) project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] logging . info ( f 'projects: { project_names } ' ) region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f } logging . info ( f 'regions: { region_names } ' ) read_text_file Read a text file from one of the static subdirectories. Parameters: project ( str ) \u2013 the project name area ( str ) \u2013 the data area (barriers, targets, colnames) fn ( str ) \u2013 the name of the file within the data area Returns: str \u2013 the contents of the file, as a single string Source code in app/main.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def read_text_file ( project : str , area : str , fn : str ) -> str : ''' Read a text file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn if not p . exists (): raise FileNotFoundError ( p ) logging . info ( f 'reading text file: { p } ' ) with open ( p ) as f : return f . read () . rstrip () projects Respond to GET requests of the form /projects . Returns: list [ str ] \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 101 102 103 104 105 106 107 108 109 @app . get ( \"/projects\" ) async def projects () -> list [ str ]: ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names barriers Respond to GET requests of the form /barriers/P where P is a project name. Returns: dict \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ) -> dict : ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'barriers: unknown project: { project } ' ) try : barriers = read_text_file ( project , BARRIERS , BARRIER_FILE ) return { 'project' : project , 'barriers' : barriers } except FileNotFoundError : raise HTTPException ( status_code = 404 , detail = f 'file not found: { BARRIERS } / { BARRIER_FILE } ' ) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' ) mapinfo Respond to GET requests of the form /mapinfo/P where P is a project name. Returns: dict \u2013 a dictionary (JSON format) with settings for displaying the map for a project. Source code in app/main.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @app . get ( \"/mapinfo/ {project} \" ) async def mapinfo ( project : str ) -> dict : ''' Respond to GET requests of the form `/mapinfo/P` where P is a project name. Returns: a dictionary (JSON format) with settings for displaying the map for a project. ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'mapinfo: unknown project: { project } ' ) try : info = read_text_file ( project , MAPS , MAPINFO_FILE ) return { 'project' : project , 'mapinfo' : info } except FileNotFoundError : raise HTTPException ( status_code = 404 , detail = f 'file not found: { MAPS } / { MAPINFO_FILE } ' ) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' ) targets Respond to GET requests of the form /targets/P where P is a project name. Returns: dict \u2013 the CSV file containing restoration target descriptions for a project dict \u2013 and a plain text file containing the layout in the GUI Source code in app/main.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @app . get ( \"/targets/ {project} \" ) async def targets ( project : str ) -> dict : ''' Respond to GET requests of the form `/targets/P` where P is a project name. Returns: the CSV file containing restoration target descriptions for a project and a plain text file containing the layout in the GUI ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'targets: unknown project: { project } ' ) try : targets = read_text_file ( project , TARGETS , TARGET_FILE ) layout = read_text_file ( project , TARGETS , LAYOUT_FILE ) return { 'project' : project , 'targets' : targets , 'layout' : layout } except FileNotFoundError as err : raise HTTPException ( status_code = 404 , detail = str ( err )) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' ) colnames Respond to GET requests of the form /colnames/P where P is a project name. Returns: dict \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ) -> dict : ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' try : assert project in project_names , f 'unknown project: { project } ' cname_dir = Path ( COLNAMES ) / project cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} elif cname_dir . is_dir (): alts = list ( cname_dir . iterdir ()) assert len ( alts ) == 1 , f 'colnames/ { project } should have exactly one folder' alt_name = alts [ 0 ] assert alt_name . is_dir (), f 'no directory for { alt_name } ' cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames } else : assert False , f 'file not found: { cname_file } ' except Exception as err : raise HTTPException ( status_code = 404 , detail = f 'colnames: { err } ' ) optipass A GET request of the form /optipass/project?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (used to make path to static files) regions ( Annotated [ list [ str ], Query ()] ) \u2013 comma-separated string of region names targets ( Annotated [ list [ str ], Query ()] ) \u2013 comma-separated string of 2-letter target IDs budgets ( Annotated [ list [ int ], Query ()] ) \u2013 a list with starting budget, increment, and count weights ( Annotated [ list [ int ] | None, Query ()] , default: None ) \u2013 list of ints, one for each target (optional) mapping ( Annotated [ list [ str ] | None, Query ()] , default: None ) \u2013 project-specific target names, e.g. current or future (optional) tempdir ( Annotated [ str | None, Query ()] , default: None ) \u2013 directory that has existing results (optional, used in testing) Returns: dict \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : Annotated [ list [ str ], Query ()], budgets : Annotated [ list [ int ], Query ()], targets : Annotated [ list [ str ], Query ()], weights : Annotated [ list [ int ] | None , Query ()] = None , mapping : Annotated [ list [ str ] | None , Query ()] = None , tempdir : Annotated [ str | None , Query ()] = None , ) -> dict : ''' A GET request of the form `/optipass/project?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (used to make path to static files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs budgets: a list with starting budget, increment, and count weights: list of ints, one for each target (optional) mapping: project-specific target names, e.g. `current` or `future` (optional) tempdir: directory that has existing results (optional, used in testing) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' logging . debug ( f 'project { project } ' ) logging . debug ( f 'regions { regions } ' ) logging . debug ( f 'budgets { budgets } ' ) logging . debug ( f 'targets { targets } ' ) logging . debug ( f 'weights { weights } ' ) logging . debug ( f 'mapping { mapping } ' ) logging . debug ( f 'tempdir { tempdir } ' ) try : assert project in project_names , f 'unknown project: { project } ' barrier_path = Path ( BARRIERS ) / project target_file = Path ( TARGETS ) / project / TARGET_FILE cname_dir = Path ( COLNAMES ) / project if mapping is None : cname_file = cname_dir / COLNAME_FILE else : cname_file = cname_dir / mapping [ 0 ] / f ' { mapping [ 1 ] } .csv' summary , matrix = run_optipass ( barrier_path , target_file , cname_file , regions , budgets , targets , weights , tempdir , ) return { 'summary' : summary . to_csv (), 'matrix' : matrix . to_csv (), } except AssertionError as err : raise HTTPException ( status_code = 404 , detail = f 'optipass: { err } ' ) except NotImplementedError : raise HTTPException ( status_code = 501 , detail = f 'OptiPassMain.exe not found' ) except RuntimeError as err : raise HTTPException ( status_code = 500 , detail = str ( err )) except Exception as err : logging . exception ( err ) raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' ) optipass.py optipass_is_installed Make sure OptiPass is installed. Returns: bool \u2013 True if OptiPass is installed and this host can run it. Source code in app/optipass.py 17 18 19 20 21 22 23 24 def optipass_is_installed () -> bool : ''' Make sure OptiPass is installed. Returns: True if OptiPass is installed and this host can run it. ''' return Path ( './bin/OptiPassMain.exe' ) and (( platform . system () == 'Windows' ) or os . environ . get ( 'WINEARCH' )) run_optipass Run OptiPass using the specified arguments. Instantiates an OP object with paths to data files, calls methods that create the input file, run the optimizer, and gather the results. Parameters: barrier_path ( str ) \u2013 name of directory with CSVs files for tide gate data target_file ( str ) \u2013 name of a CSV file with restoration target descriptions mapping_file ( str ) \u2013 name of CSV file with barrier passabilities regions ( list [ str ] ) \u2013 a list of geographic regions (river names) to use budgets ( list [ int ] ) \u2013 a list with starting budget, budget increment, and number of budgets targets ( list [ str ] ) \u2013 a list of IDs of targets to use weights ( list [ int ] ) \u2013 a list of target weights tmpdir ( Path | None , default: None ) \u2013 name of directory that has existing results (used for testing) Returns: tuple \u2013 a tuple containing two data frames, a budget table and a gate matrix Source code in app/optipass.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def run_optipass ( barrier_path : str , target_file : str , mapping_file : str , regions : list [ str ], budgets : list [ int ], targets : list [ str ], weights : list [ int ], tmpdir : Path | None = None , ) -> tuple : ''' Run OptiPass using the specified arguments. Instantiates an OP object with paths to data files, calls methods that create the input file, run the optimizer, and gather the results. Arguments: barrier_path: name of directory with CSVs files for tide gate data target_file: name of a CSV file with restoration target descriptions mapping_file: name of CSV file with barrier passabilities regions: a list of geographic regions (river names) to use budgets: a list with starting budget, budget increment, and number of budgets targets: a list of IDs of targets to use weights: a list of target weights tmpdir: name of directory that has existing results (used for testing) Returns: a tuple containing two data frames, a budget table and a gate matrix ''' op = OptiPass ( barrier_path , target_file , mapping_file , regions , targets , weights , tmpdir ) op . create_input_frame () op . create_paths () op . run ( * budgets ) return op . collect_results () OptiPass An instance of this class has all the data and methods required to respond to an optipass request. The entry point that runs OptiPass has query parameters that specify how many budget levels to explore. We need to run OptiPass.exe once for each budget level, then collect the results. The general workflow: create an instance of this class, passing the constructor the parameter values for the regions, targets, and budget levels call a method to generate the input file (called a \"barrier file\" in the OP documentation) that will be read as input each time OP runs call the method that finds downstream barriers call the method that runs OP generate the output tables and plots All of the intermediate data needed for these steps is saved in instance vars of the object. Parameters: barriers ( str ) \u2013 folder with barrier definitions tfile ( str ) \u2013 name of file with target descriptions mfile ( str ) \u2013 name of file with target benefits rlist ( list [ str ] ) \u2013 list of region names tlist ( list [ str ] ) \u2013 list of target names weights ( list [ int ] | None , default: None ) \u2013 list of target weights (optional) tmpdir ( str | None , default: None ) \u2013 path to output files (optional, used by unit tests) Source code in app/optipass.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , barriers : str , tfile : str , mfile : str , rlist : list [ str ], tlist : list [ str ], weights : list [ int ] | None = None , tmpdir : str | None = None ): ''' Instantiate a new OP object. Arguments: barriers: folder with barrier definitions tfile: name of file with target descriptions mfile: name of file with target benefits rlist: list of region names tlist: list of target names weights: list of target weights (optional) tmpdir: path to output files (optional, used by unit tests) ''' bf = pd . read_csv ( barriers / 'barriers.csv' ) self . barriers = bf [ bf . region . isin ( rlist )] pf = pd . read_csv ( barriers / 'passability.csv' ) self . passability = pf [ pf . ID . isin ( self . barriers . ID )] tf = pd . read_csv ( tfile ) . set_index ( 'abbrev' ) assert all ( t in tf . index for t in tlist ), f 'unknown target name in { tlist } ' self . targets = tf [ tf . index . isin ( tlist )] mf = pd . read_csv ( mfile ) . set_index ( 'abbrev' ) self . mapping = mf [ mf . index . isin ( tlist )] self . set_target_weights ( weights ) self . tmpdir = Path ( tmpdir ) if tmpdir else None self . input_frame = None self . paths = None self . summary = None self . matrix = None create_input_frame () Build a data frame that has the rows that will be passed to OptiPass. This frame is basically a subset of the columns of the barrier frame, using column names defined in the targets frame. The frame is saved as an instance variable of this object. Source code in app/optipass.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def create_input_frame ( self ): ''' Build a data frame that has the rows that will be passed to OptiPass. This frame is basically a subset of the columns of the barrier frame, using column names defined in the targets frame. The frame is saved as an instance variable of this object. ''' # Initialize the output frame (df) with the ID and region columns # from the data set df = self . barriers [[ 'ID' , 'region' ]] header = [ 'ID' , 'REG' ] # The FOCUS column is all 1's df = pd . concat ([ df , pd . Series ( np . ones ( len ( self . barriers )), name = 'FOCUS' , dtype = int , index = self . barriers . index )], axis = 1 ) header . append ( 'FOCUS' ) # Copy the downstream ID column df = pd . concat ([ df , self . barriers [ 'DSID' ]], axis = 1 ) header . append ( 'DSID' ) # Add habitat column for each target. The name of the column to copy is # in the mapping frame, the column to copy is in the passability frame for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'habitat' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'HAB_' + t ) # Same, but for pre-mitigation passage values for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'prepass' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'PRE_' + t ) # Copy the NPROJ column (1 if a gate is used, 0 if not) df = pd . concat ([ df , self . barriers [ 'NPROJ' ]], axis = 1 ) header . append ( 'NPROJ' ) # The ACTION column is always all 0 (we consider only one scenario) df = pd . concat ([ df , pd . Series ( np . zeros ( len ( self . barriers )), name = 'ACTION' , dtype = int , index = self . barriers . index )], axis = 1 ) header . append ( 'ACTION' ) # Copy the cost to fix a gate df = pd . concat ([ df , self . barriers [ 'cost' ]], axis = 1 ) header += [ 'COST' ] # Same logic as above, copy the post-mitigation passage for each target for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'postpass' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'POST_' + t ) # All done making the data -- use the new column headers and save the frame df . columns = header self . input_frame = df create_paths () Create paths downstream from each gate (the paths will be used to compute cumulative passability). The paths are saved in an instance variable. Source code in app/optipass.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def create_paths ( self ): ''' Create paths downstream from each gate (the paths will be used to compute cumulative passability). The paths are saved in an instance variable. ''' df = self . input_frame G = nx . from_pandas_edgelist ( df [ df . DSID . notnull ()], source = 'ID' , target = 'DSID' , create_using = nx . DiGraph ) for x in df [ df . DSID . isnull ()] . ID : G . add_node ( x ) self . paths = { n : self . path_from ( n , G ) for n in G . nodes } path_from ( x , graph ) Helper function used to create paths -- return a list of nodes in the path from x to a downstream barrier that has no descendants. Parameters: x ( str ) \u2013 a barrier ID graph ( DiGraph ) \u2013 a digraph based on downstream IDs Returns: list \u2013 a list of all barriers downstream from x Source code in app/optipass.py 201 202 203 204 205 206 207 208 209 210 211 212 213 def path_from ( self , x : str , graph : nx . DiGraph ) -> list : ''' Helper function used to create paths -- return a list of nodes in the path from `x` to a downstream barrier that has no descendants. Arguments: x: a barrier ID graph: a digraph based on downstream IDs Returns: a list of all barriers downstream from x ''' return [ x ] + [ child for _ , child in nx . dfs_edges ( graph , x )] set_target_weights ( weights ) Create the target weight values that will be passed on the command line when OptiPass is run. If the list is None set each weight to 1. Weights are saved in an instance variable. Parameters: weights ( list [ int ] | None ) \u2013 None if the user did not specify weighrs, otherwise the list of integer weights from the GUI Source code in app/optipass.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def set_target_weights ( self , weights : list [ int ] | None ): ''' Create the target weight values that will be passed on the command line when OptiPass is run. If the list is None set each weight to 1. Weights are saved in an instance variable. Arguments: weights: None if the user did not specify weighrs, otherwise the list of integer weights from the GUI ''' if weights : self . weights = weights self . weighted = True else : self . weights = [ 1 ] * len ( self . targets ) self . weighted = False run ( bmin , bdelta , bcount ) Run Optipass once for each budget level. Create the shell commands and run them. Outputs are saved in a temp directory. Parameters: bmin ( int ) \u2013 starting budget level bdelta ( int ) \u2013 budget increment bcount ( int ) \u2013 number of budgets Note: for unit tests the outputs are already in the temp directory so OptiPass isn't run when running OptiPass run it once with a budget of $0 and then once for each budget level Source code in app/optipass.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def run ( self , bmin : int , bdelta : int , bcount : int ): ''' Run Optipass once for each budget level. Create the shell commands and run them. Outputs are saved in a temp directory. Arguments: bmin: starting budget level bdelta: budget increment bcount: number of budgets Note: * for unit tests the outputs are already in the temp directory so OptiPass isn't run * when running OptiPass run it once with a budget of $0 and then once for each budget level ''' if self . tmpdir is not None : logging . info ( f 'Using saved results in { self . tmpdir } ' ) return if not optipass_is_installed (): raise NotImplementedError ( 'OptiPassMain.exe not found' ) self . tmpdir = Path ( tempfile . mkdtemp ( prefix = 'op' , dir = 'tmp' )) barrier_file = self . tmpdir / 'input.txt' self . input_frame . to_csv ( barrier_file , index = False , sep = ' \\t ' , lineterminator = os . linesep , na_rep = 'NA' ) template = 'bin \\\\ OptiPassMain.exe -f {bf} -o {of} -b {n} ' budget = bmin for i in range ( bcount + 1 ): outfile = self . tmpdir / f 'output_ { i } .txt' cmnd = template . format ( bf = barrier_file , of = outfile , n = budget ) if ( num_targets := len ( self . targets )) > 1 : cmnd += ' -t {} ' . format ( num_targets ) cmnd += ' -w ' + ', ' . join ([ str ( n ) for n in self . weights ]) res = subprocess . run ( cmnd , shell = True , capture_output = True ) logging . info ( cmnd ) resp = res . stdout . decode () if re . search ( r 'error' , resp , re . I ): logging . error ( f 'OptiPassMain.exe: { resp } ' ) raise RuntimeError ( resp ) budget += bdelta n = len ( list ( self . tmpdir . glob ( 'output*.txt' ))) if n < bcount + 1 : raise RuntimeError ( f 'No output for { bcount - n } of { bcount } optimizations' ) collect_results () OptiPass makes one output file for each budget level. Iterate over those files to gather results into a pair of data frames. Returns: tuple \u2013 a tuple with two data frames, one for budgets, the other for barriers Source code in app/optipass.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def collect_results ( self ) -> tuple : ''' OptiPass makes one output file for each budget level. Iterate over those files to gather results into a pair of data frames. Returns: a tuple with two data frames, one for budgets, the other for barriers ''' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} for fn in sorted ( self . tmpdir . glob ( 'output_*.txt' ), key = lambda p : int ( p . stem [ 7 :])): self . parse_output ( fn , cols ) self . summary = pd . DataFrame ( cols ) dct = {} for i in range ( len ( self . summary )): b = int ( self . summary . budget [ i ]) dct [ b ] = [ 1 if g in self . summary . gates [ i ] else 0 for g in self . input_frame . ID ] self . matrix = pd . DataFrame ( dct , index = self . input_frame . ID ) self . matrix [ 'count' ] = self . matrix . sum ( axis = 1 ) self . add_potential_habitat () return self . summary , self . matrix parse_output ( fn , dct ) Parse an output file, appending results to the lists in dct. We need to handle two different formats, depending on whether there was one target or more than one. Values extracted from a file are appended to the lists passed in the dictionary argument. Parameters: fn ( str ) \u2013 the name of the file to parse dct ( dict ) \u2013 a dictionary containing lists for budget, habitat, and gate values Source code in app/optipass.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def parse_output ( self , fn : str , dct : dict ): ''' Parse an output file, appending results to the lists in dct. We need to handle two different formats, depending on whether there was one target or more than one. Values extracted from a file are appended to the lists passed in the dictionary argument. Arguments: fn: the name of the file to parse dct: a dictionary containing lists for budget, habitat, and gate values ''' def parse_header_line ( line , tag ): tokens = line . strip () . split () if not tokens [ 0 ] . startswith ( tag ): return None return tokens [ 1 ] logging . debug ( f 'parsing { fn } ' ) with open ( fn ) as f : amount = parse_header_line ( f . readline (), 'BUDGET' ) dct [ 'budget' ] . append ( float ( amount )) if parse_header_line ( f . readline (), 'STATUS' ) == 'NO_SOLN' : raise RuntimeError ( 'No solution' ) f . readline () # skip OPTGAP line = f . readline () if line . startswith ( 'PTNL' ): # this file has only one target hab = parse_header_line ( line , 'PTNL_HABITAT' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip NETGAIN else : # multiple targets; skip past individual weights and targets while line := f . readline (): if line . startswith ( 'WT_PTNL_HAB' ): break hab = parse_header_line ( line , 'WT_PTNL_HAB' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip WT_NETGAIN f . readline () # skip blank line f . readline () # skip header lst = [] while line := f . readline (): name , action = line . strip () . split () if action == '1' : lst . append ( name ) dct [ 'gates' ] . append ( lst ) add_potential_habitat () Compute the potential habitat available after restoration, using the original unscaled habitat values. Adds a new table named summary: one column for each target, showing the potential habitat gain at each budget level, then the weighted potential habitat over all targets, and finally the net gain. Source code in app/optipass.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def add_potential_habitat ( self ): ''' Compute the potential habitat available after restoration, using the original unscaled habitat values. Adds a new table named summary: one column for each target, showing the potential habitat gain at each budget level, then the weighted potential habitat over all targets, and finally the net gain. ''' # make a copy of the passability data with NaN replaced by 0s and using the # barrier ID as the index df = self . passability . fillna ( 0 ) . set_index ( 'ID' ) wph = np . zeros ( len ( self . summary )) for i in range ( len ( self . targets )): t = self . mapping . iloc [ i ] cp = self . _ah ( t , df ) * self . weights [ i ] wph += cp col = pd . DataFrame ({ t . name : cp }) self . summary = pd . concat ([ self . summary , col ], axis = 1 ) gain = self . _gain ( t . name , t , df ) mcol = df [ t . unscaled ] mcol . name = t . name self . matrix = pd . concat ([ self . matrix , mcol , gain ], axis = 1 ) self . summary = pd . concat ([ self . summary , pd . DataFrame ({ 'wph' : wph })], axis = 1 ) self . summary [ 'netgain' ] = self . summary . habitat - self . summary . habitat [ 0 ]","title":"Modules"},{"location":"modules/#modules","text":"The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one ( optipass.py ) that provides an abstract interface for running OptiPass. app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py","title":"Modules"},{"location":"modules/#mainpy","text":"","title":"main.py"},{"location":"modules/#init","text":"Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE global MAPS , MAPINFO_FILE global TARGETS , TARGET_FILE , LAYOUT_FILE global COLNAMES , COLNAME_FILE global HTMLDIR , IMAGEDIR MAPS = 'static/maps' MAPINFO_FILE = 'mapinfo.json' BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' LAYOUT_FILE = 'layout.txt' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' HTMLDIR = 'static/html' # IMAGEDIR = 'static/images' global project_names , region_names logging . basicConfig ( level = logging . INFO , style = '{' , format = ' {message} ' , handlers = [ RichHandler ( markup = True , rich_tracebacks = True )], ) project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] logging . info ( f 'projects: { project_names } ' ) region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f } logging . info ( f 'regions: { region_names } ' )","title":"init"},{"location":"modules/#read_text_file","text":"Read a text file from one of the static subdirectories. Parameters: project ( str ) \u2013 the project name area ( str ) \u2013 the data area (barriers, targets, colnames) fn ( str ) \u2013 the name of the file within the data area Returns: str \u2013 the contents of the file, as a single string Source code in app/main.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def read_text_file ( project : str , area : str , fn : str ) -> str : ''' Read a text file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn if not p . exists (): raise FileNotFoundError ( p ) logging . info ( f 'reading text file: { p } ' ) with open ( p ) as f : return f . read () . rstrip ()","title":"read_text_file"},{"location":"modules/#projects","text":"Respond to GET requests of the form /projects . Returns: list [ str ] \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 101 102 103 104 105 106 107 108 109 @app . get ( \"/projects\" ) async def projects () -> list [ str ]: ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names","title":"projects"},{"location":"modules/#barriers","text":"Respond to GET requests of the form /barriers/P where P is a project name. Returns: dict \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ) -> dict : ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'barriers: unknown project: { project } ' ) try : barriers = read_text_file ( project , BARRIERS , BARRIER_FILE ) return { 'project' : project , 'barriers' : barriers } except FileNotFoundError : raise HTTPException ( status_code = 404 , detail = f 'file not found: { BARRIERS } / { BARRIER_FILE } ' ) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' )","title":"barriers"},{"location":"modules/#mapinfo","text":"Respond to GET requests of the form /mapinfo/P where P is a project name. Returns: dict \u2013 a dictionary (JSON format) with settings for displaying the map for a project. Source code in app/main.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 @app . get ( \"/mapinfo/ {project} \" ) async def mapinfo ( project : str ) -> dict : ''' Respond to GET requests of the form `/mapinfo/P` where P is a project name. Returns: a dictionary (JSON format) with settings for displaying the map for a project. ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'mapinfo: unknown project: { project } ' ) try : info = read_text_file ( project , MAPS , MAPINFO_FILE ) return { 'project' : project , 'mapinfo' : info } except FileNotFoundError : raise HTTPException ( status_code = 404 , detail = f 'file not found: { MAPS } / { MAPINFO_FILE } ' ) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' )","title":"mapinfo"},{"location":"modules/#targets","text":"Respond to GET requests of the form /targets/P where P is a project name. Returns: dict \u2013 the CSV file containing restoration target descriptions for a project dict \u2013 and a plain text file containing the layout in the GUI Source code in app/main.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 @app . get ( \"/targets/ {project} \" ) async def targets ( project : str ) -> dict : ''' Respond to GET requests of the form `/targets/P` where P is a project name. Returns: the CSV file containing restoration target descriptions for a project and a plain text file containing the layout in the GUI ''' if project not in project_names : raise HTTPException ( status_code = 404 , detail = f 'targets: unknown project: { project } ' ) try : targets = read_text_file ( project , TARGETS , TARGET_FILE ) layout = read_text_file ( project , TARGETS , LAYOUT_FILE ) return { 'project' : project , 'targets' : targets , 'layout' : layout } except FileNotFoundError as err : raise HTTPException ( status_code = 404 , detail = str ( err )) except Exception as err : raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' )","title":"targets"},{"location":"modules/#colnames","text":"Respond to GET requests of the form /colnames/P where P is a project name. Returns: dict \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ) -> dict : ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' try : assert project in project_names , f 'unknown project: { project } ' cname_dir = Path ( COLNAMES ) / project cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} elif cname_dir . is_dir (): alts = list ( cname_dir . iterdir ()) assert len ( alts ) == 1 , f 'colnames/ { project } should have exactly one folder' alt_name = alts [ 0 ] assert alt_name . is_dir (), f 'no directory for { alt_name } ' cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames } else : assert False , f 'file not found: { cname_file } ' except Exception as err : raise HTTPException ( status_code = 404 , detail = f 'colnames: { err } ' )","title":"colnames"},{"location":"modules/#optipass","text":"A GET request of the form /optipass/project?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (used to make path to static files) regions ( Annotated [ list [ str ], Query ()] ) \u2013 comma-separated string of region names targets ( Annotated [ list [ str ], Query ()] ) \u2013 comma-separated string of 2-letter target IDs budgets ( Annotated [ list [ int ], Query ()] ) \u2013 a list with starting budget, increment, and count weights ( Annotated [ list [ int ] | None, Query ()] , default: None ) \u2013 list of ints, one for each target (optional) mapping ( Annotated [ list [ str ] | None, Query ()] , default: None ) \u2013 project-specific target names, e.g. current or future (optional) tempdir ( Annotated [ str | None, Query ()] , default: None ) \u2013 directory that has existing results (optional, used in testing) Returns: dict \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : Annotated [ list [ str ], Query ()], budgets : Annotated [ list [ int ], Query ()], targets : Annotated [ list [ str ], Query ()], weights : Annotated [ list [ int ] | None , Query ()] = None , mapping : Annotated [ list [ str ] | None , Query ()] = None , tempdir : Annotated [ str | None , Query ()] = None , ) -> dict : ''' A GET request of the form `/optipass/project?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (used to make path to static files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs budgets: a list with starting budget, increment, and count weights: list of ints, one for each target (optional) mapping: project-specific target names, e.g. `current` or `future` (optional) tempdir: directory that has existing results (optional, used in testing) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' logging . debug ( f 'project { project } ' ) logging . debug ( f 'regions { regions } ' ) logging . debug ( f 'budgets { budgets } ' ) logging . debug ( f 'targets { targets } ' ) logging . debug ( f 'weights { weights } ' ) logging . debug ( f 'mapping { mapping } ' ) logging . debug ( f 'tempdir { tempdir } ' ) try : assert project in project_names , f 'unknown project: { project } ' barrier_path = Path ( BARRIERS ) / project target_file = Path ( TARGETS ) / project / TARGET_FILE cname_dir = Path ( COLNAMES ) / project if mapping is None : cname_file = cname_dir / COLNAME_FILE else : cname_file = cname_dir / mapping [ 0 ] / f ' { mapping [ 1 ] } .csv' summary , matrix = run_optipass ( barrier_path , target_file , cname_file , regions , budgets , targets , weights , tempdir , ) return { 'summary' : summary . to_csv (), 'matrix' : matrix . to_csv (), } except AssertionError as err : raise HTTPException ( status_code = 404 , detail = f 'optipass: { err } ' ) except NotImplementedError : raise HTTPException ( status_code = 501 , detail = f 'OptiPassMain.exe not found' ) except RuntimeError as err : raise HTTPException ( status_code = 500 , detail = str ( err )) except Exception as err : logging . exception ( err ) raise HTTPException ( status_code = 500 , detail = f 'server error: { err } ' )","title":"optipass"},{"location":"modules/#optipasspy","text":"","title":"optipass.py"},{"location":"modules/#optipass_is_installed","text":"Make sure OptiPass is installed. Returns: bool \u2013 True if OptiPass is installed and this host can run it. Source code in app/optipass.py 17 18 19 20 21 22 23 24 def optipass_is_installed () -> bool : ''' Make sure OptiPass is installed. Returns: True if OptiPass is installed and this host can run it. ''' return Path ( './bin/OptiPassMain.exe' ) and (( platform . system () == 'Windows' ) or os . environ . get ( 'WINEARCH' ))","title":"optipass_is_installed"},{"location":"modules/#run_optipass","text":"Run OptiPass using the specified arguments. Instantiates an OP object with paths to data files, calls methods that create the input file, run the optimizer, and gather the results. Parameters: barrier_path ( str ) \u2013 name of directory with CSVs files for tide gate data target_file ( str ) \u2013 name of a CSV file with restoration target descriptions mapping_file ( str ) \u2013 name of CSV file with barrier passabilities regions ( list [ str ] ) \u2013 a list of geographic regions (river names) to use budgets ( list [ int ] ) \u2013 a list with starting budget, budget increment, and number of budgets targets ( list [ str ] ) \u2013 a list of IDs of targets to use weights ( list [ int ] ) \u2013 a list of target weights tmpdir ( Path | None , default: None ) \u2013 name of directory that has existing results (used for testing) Returns: tuple \u2013 a tuple containing two data frames, a budget table and a gate matrix Source code in app/optipass.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def run_optipass ( barrier_path : str , target_file : str , mapping_file : str , regions : list [ str ], budgets : list [ int ], targets : list [ str ], weights : list [ int ], tmpdir : Path | None = None , ) -> tuple : ''' Run OptiPass using the specified arguments. Instantiates an OP object with paths to data files, calls methods that create the input file, run the optimizer, and gather the results. Arguments: barrier_path: name of directory with CSVs files for tide gate data target_file: name of a CSV file with restoration target descriptions mapping_file: name of CSV file with barrier passabilities regions: a list of geographic regions (river names) to use budgets: a list with starting budget, budget increment, and number of budgets targets: a list of IDs of targets to use weights: a list of target weights tmpdir: name of directory that has existing results (used for testing) Returns: a tuple containing two data frames, a budget table and a gate matrix ''' op = OptiPass ( barrier_path , target_file , mapping_file , regions , targets , weights , tmpdir ) op . create_input_frame () op . create_paths () op . run ( * budgets ) return op . collect_results ()","title":"run_optipass"},{"location":"modules/#optipass_1","text":"An instance of this class has all the data and methods required to respond to an optipass request. The entry point that runs OptiPass has query parameters that specify how many budget levels to explore. We need to run OptiPass.exe once for each budget level, then collect the results. The general workflow: create an instance of this class, passing the constructor the parameter values for the regions, targets, and budget levels call a method to generate the input file (called a \"barrier file\" in the OP documentation) that will be read as input each time OP runs call the method that finds downstream barriers call the method that runs OP generate the output tables and plots All of the intermediate data needed for these steps is saved in instance vars of the object. Parameters: barriers ( str ) \u2013 folder with barrier definitions tfile ( str ) \u2013 name of file with target descriptions mfile ( str ) \u2013 name of file with target benefits rlist ( list [ str ] ) \u2013 list of region names tlist ( list [ str ] ) \u2013 list of target names weights ( list [ int ] | None , default: None ) \u2013 list of target weights (optional) tmpdir ( str | None , default: None ) \u2013 path to output files (optional, used by unit tests) Source code in app/optipass.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def __init__ ( self , barriers : str , tfile : str , mfile : str , rlist : list [ str ], tlist : list [ str ], weights : list [ int ] | None = None , tmpdir : str | None = None ): ''' Instantiate a new OP object. Arguments: barriers: folder with barrier definitions tfile: name of file with target descriptions mfile: name of file with target benefits rlist: list of region names tlist: list of target names weights: list of target weights (optional) tmpdir: path to output files (optional, used by unit tests) ''' bf = pd . read_csv ( barriers / 'barriers.csv' ) self . barriers = bf [ bf . region . isin ( rlist )] pf = pd . read_csv ( barriers / 'passability.csv' ) self . passability = pf [ pf . ID . isin ( self . barriers . ID )] tf = pd . read_csv ( tfile ) . set_index ( 'abbrev' ) assert all ( t in tf . index for t in tlist ), f 'unknown target name in { tlist } ' self . targets = tf [ tf . index . isin ( tlist )] mf = pd . read_csv ( mfile ) . set_index ( 'abbrev' ) self . mapping = mf [ mf . index . isin ( tlist )] self . set_target_weights ( weights ) self . tmpdir = Path ( tmpdir ) if tmpdir else None self . input_frame = None self . paths = None self . summary = None self . matrix = None","title":"OptiPass"},{"location":"modules/#app.optipass.OptiPass.create_input_frame","text":"Build a data frame that has the rows that will be passed to OptiPass. This frame is basically a subset of the columns of the barrier frame, using column names defined in the targets frame. The frame is saved as an instance variable of this object. Source code in app/optipass.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def create_input_frame ( self ): ''' Build a data frame that has the rows that will be passed to OptiPass. This frame is basically a subset of the columns of the barrier frame, using column names defined in the targets frame. The frame is saved as an instance variable of this object. ''' # Initialize the output frame (df) with the ID and region columns # from the data set df = self . barriers [[ 'ID' , 'region' ]] header = [ 'ID' , 'REG' ] # The FOCUS column is all 1's df = pd . concat ([ df , pd . Series ( np . ones ( len ( self . barriers )), name = 'FOCUS' , dtype = int , index = self . barriers . index )], axis = 1 ) header . append ( 'FOCUS' ) # Copy the downstream ID column df = pd . concat ([ df , self . barriers [ 'DSID' ]], axis = 1 ) header . append ( 'DSID' ) # Add habitat column for each target. The name of the column to copy is # in the mapping frame, the column to copy is in the passability frame for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'habitat' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'HAB_' + t ) # Same, but for pre-mitigation passage values for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'prepass' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'PRE_' + t ) # Copy the NPROJ column (1 if a gate is used, 0 if not) df = pd . concat ([ df , self . barriers [ 'NPROJ' ]], axis = 1 ) header . append ( 'NPROJ' ) # The ACTION column is always all 0 (we consider only one scenario) df = pd . concat ([ df , pd . Series ( np . zeros ( len ( self . barriers )), name = 'ACTION' , dtype = int , index = self . barriers . index )], axis = 1 ) header . append ( 'ACTION' ) # Copy the cost to fix a gate df = pd . concat ([ df , self . barriers [ 'cost' ]], axis = 1 ) header += [ 'COST' ] # Same logic as above, copy the post-mitigation passage for each target for t in self . targets . index : col = self . passability [ self . mapping . loc [ t , 'postpass' ]] df = pd . concat ([ df , col ], axis = 1 ) header . append ( 'POST_' + t ) # All done making the data -- use the new column headers and save the frame df . columns = header self . input_frame = df","title":"create_input_frame"},{"location":"modules/#app.optipass.OptiPass.create_paths","text":"Create paths downstream from each gate (the paths will be used to compute cumulative passability). The paths are saved in an instance variable. Source code in app/optipass.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def create_paths ( self ): ''' Create paths downstream from each gate (the paths will be used to compute cumulative passability). The paths are saved in an instance variable. ''' df = self . input_frame G = nx . from_pandas_edgelist ( df [ df . DSID . notnull ()], source = 'ID' , target = 'DSID' , create_using = nx . DiGraph ) for x in df [ df . DSID . isnull ()] . ID : G . add_node ( x ) self . paths = { n : self . path_from ( n , G ) for n in G . nodes }","title":"create_paths"},{"location":"modules/#app.optipass.OptiPass.path_from","text":"Helper function used to create paths -- return a list of nodes in the path from x to a downstream barrier that has no descendants. Parameters: x ( str ) \u2013 a barrier ID graph ( DiGraph ) \u2013 a digraph based on downstream IDs Returns: list \u2013 a list of all barriers downstream from x Source code in app/optipass.py 201 202 203 204 205 206 207 208 209 210 211 212 213 def path_from ( self , x : str , graph : nx . DiGraph ) -> list : ''' Helper function used to create paths -- return a list of nodes in the path from `x` to a downstream barrier that has no descendants. Arguments: x: a barrier ID graph: a digraph based on downstream IDs Returns: a list of all barriers downstream from x ''' return [ x ] + [ child for _ , child in nx . dfs_edges ( graph , x )]","title":"path_from"},{"location":"modules/#app.optipass.OptiPass.set_target_weights","text":"Create the target weight values that will be passed on the command line when OptiPass is run. If the list is None set each weight to 1. Weights are saved in an instance variable. Parameters: weights ( list [ int ] | None ) \u2013 None if the user did not specify weighrs, otherwise the list of integer weights from the GUI Source code in app/optipass.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def set_target_weights ( self , weights : list [ int ] | None ): ''' Create the target weight values that will be passed on the command line when OptiPass is run. If the list is None set each weight to 1. Weights are saved in an instance variable. Arguments: weights: None if the user did not specify weighrs, otherwise the list of integer weights from the GUI ''' if weights : self . weights = weights self . weighted = True else : self . weights = [ 1 ] * len ( self . targets ) self . weighted = False","title":"set_target_weights"},{"location":"modules/#app.optipass.OptiPass.run","text":"Run Optipass once for each budget level. Create the shell commands and run them. Outputs are saved in a temp directory. Parameters: bmin ( int ) \u2013 starting budget level bdelta ( int ) \u2013 budget increment bcount ( int ) \u2013 number of budgets Note: for unit tests the outputs are already in the temp directory so OptiPass isn't run when running OptiPass run it once with a budget of $0 and then once for each budget level Source code in app/optipass.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def run ( self , bmin : int , bdelta : int , bcount : int ): ''' Run Optipass once for each budget level. Create the shell commands and run them. Outputs are saved in a temp directory. Arguments: bmin: starting budget level bdelta: budget increment bcount: number of budgets Note: * for unit tests the outputs are already in the temp directory so OptiPass isn't run * when running OptiPass run it once with a budget of $0 and then once for each budget level ''' if self . tmpdir is not None : logging . info ( f 'Using saved results in { self . tmpdir } ' ) return if not optipass_is_installed (): raise NotImplementedError ( 'OptiPassMain.exe not found' ) self . tmpdir = Path ( tempfile . mkdtemp ( prefix = 'op' , dir = 'tmp' )) barrier_file = self . tmpdir / 'input.txt' self . input_frame . to_csv ( barrier_file , index = False , sep = ' \\t ' , lineterminator = os . linesep , na_rep = 'NA' ) template = 'bin \\\\ OptiPassMain.exe -f {bf} -o {of} -b {n} ' budget = bmin for i in range ( bcount + 1 ): outfile = self . tmpdir / f 'output_ { i } .txt' cmnd = template . format ( bf = barrier_file , of = outfile , n = budget ) if ( num_targets := len ( self . targets )) > 1 : cmnd += ' -t {} ' . format ( num_targets ) cmnd += ' -w ' + ', ' . join ([ str ( n ) for n in self . weights ]) res = subprocess . run ( cmnd , shell = True , capture_output = True ) logging . info ( cmnd ) resp = res . stdout . decode () if re . search ( r 'error' , resp , re . I ): logging . error ( f 'OptiPassMain.exe: { resp } ' ) raise RuntimeError ( resp ) budget += bdelta n = len ( list ( self . tmpdir . glob ( 'output*.txt' ))) if n < bcount + 1 : raise RuntimeError ( f 'No output for { bcount - n } of { bcount } optimizations' )","title":"run"},{"location":"modules/#app.optipass.OptiPass.collect_results","text":"OptiPass makes one output file for each budget level. Iterate over those files to gather results into a pair of data frames. Returns: tuple \u2013 a tuple with two data frames, one for budgets, the other for barriers Source code in app/optipass.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 def collect_results ( self ) -> tuple : ''' OptiPass makes one output file for each budget level. Iterate over those files to gather results into a pair of data frames. Returns: a tuple with two data frames, one for budgets, the other for barriers ''' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} for fn in sorted ( self . tmpdir . glob ( 'output_*.txt' ), key = lambda p : int ( p . stem [ 7 :])): self . parse_output ( fn , cols ) self . summary = pd . DataFrame ( cols ) dct = {} for i in range ( len ( self . summary )): b = int ( self . summary . budget [ i ]) dct [ b ] = [ 1 if g in self . summary . gates [ i ] else 0 for g in self . input_frame . ID ] self . matrix = pd . DataFrame ( dct , index = self . input_frame . ID ) self . matrix [ 'count' ] = self . matrix . sum ( axis = 1 ) self . add_potential_habitat () return self . summary , self . matrix","title":"collect_results"},{"location":"modules/#app.optipass.OptiPass.parse_output","text":"Parse an output file, appending results to the lists in dct. We need to handle two different formats, depending on whether there was one target or more than one. Values extracted from a file are appended to the lists passed in the dictionary argument. Parameters: fn ( str ) \u2013 the name of the file to parse dct ( dict ) \u2013 a dictionary containing lists for budget, habitat, and gate values Source code in app/optipass.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def parse_output ( self , fn : str , dct : dict ): ''' Parse an output file, appending results to the lists in dct. We need to handle two different formats, depending on whether there was one target or more than one. Values extracted from a file are appended to the lists passed in the dictionary argument. Arguments: fn: the name of the file to parse dct: a dictionary containing lists for budget, habitat, and gate values ''' def parse_header_line ( line , tag ): tokens = line . strip () . split () if not tokens [ 0 ] . startswith ( tag ): return None return tokens [ 1 ] logging . debug ( f 'parsing { fn } ' ) with open ( fn ) as f : amount = parse_header_line ( f . readline (), 'BUDGET' ) dct [ 'budget' ] . append ( float ( amount )) if parse_header_line ( f . readline (), 'STATUS' ) == 'NO_SOLN' : raise RuntimeError ( 'No solution' ) f . readline () # skip OPTGAP line = f . readline () if line . startswith ( 'PTNL' ): # this file has only one target hab = parse_header_line ( line , 'PTNL_HABITAT' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip NETGAIN else : # multiple targets; skip past individual weights and targets while line := f . readline (): if line . startswith ( 'WT_PTNL_HAB' ): break hab = parse_header_line ( line , 'WT_PTNL_HAB' ) dct [ 'habitat' ] . append ( float ( hab )) f . readline () # skip WT_NETGAIN f . readline () # skip blank line f . readline () # skip header lst = [] while line := f . readline (): name , action = line . strip () . split () if action == '1' : lst . append ( name ) dct [ 'gates' ] . append ( lst )","title":"parse_output"},{"location":"modules/#app.optipass.OptiPass.add_potential_habitat","text":"Compute the potential habitat available after restoration, using the original unscaled habitat values. Adds a new table named summary: one column for each target, showing the potential habitat gain at each budget level, then the weighted potential habitat over all targets, and finally the net gain. Source code in app/optipass.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 def add_potential_habitat ( self ): ''' Compute the potential habitat available after restoration, using the original unscaled habitat values. Adds a new table named summary: one column for each target, showing the potential habitat gain at each budget level, then the weighted potential habitat over all targets, and finally the net gain. ''' # make a copy of the passability data with NaN replaced by 0s and using the # barrier ID as the index df = self . passability . fillna ( 0 ) . set_index ( 'ID' ) wph = np . zeros ( len ( self . summary )) for i in range ( len ( self . targets )): t = self . mapping . iloc [ i ] cp = self . _ah ( t , df ) * self . weights [ i ] wph += cp col = pd . DataFrame ({ t . name : cp }) self . summary = pd . concat ([ self . summary , col ], axis = 1 ) gain = self . _gain ( t . name , t , df ) mcol = df [ t . unscaled ] mcol . name = t . name self . matrix = pd . concat ([ self . matrix , mcol , gain ], axis = 1 ) self . summary = pd . concat ([ self . summary , pd . DataFrame ({ 'wph' : wph })], axis = 1 ) self . summary [ 'netgain' ] = self . summary . habitat - self . summary . habitat [ 0 ]","title":"add_potential_habitat"},{"location":"tests/","text":"Unit Tests Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_main.py has functions that test each of the paths defined in main.py test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py Tests for main.py test_projects () Make sure the demo project is one of the projectes. Source code in test/test_main.py 14 15 16 17 18 19 20 def test_projects (): ''' Make sure the demo project is one of the projectes. ''' resp = client . get ( '/projects' ) lst = resp . json () assert 'demo' in lst test_html_demo () Fetch the welcome message for the demo project, look for key words Source code in test/test_main.py 22 23 24 25 26 27 28 29 30 def test_html_demo (): ''' Fetch the welcome message for the demo project, look for key words ''' resp = client . get ( '/html/demo/welcome.html' ) s = resp . json () assert s . count ( '<p>' ) == 11 assert s . count ( 'OptiPass' ) == 9 assert s . count ( 'FastAPI' ) == 1 test_barriers_demo () Test the barriers entry point Source code in test/test_main.py 32 33 34 35 36 37 38 39 40 41 42 43 44 def test_barriers_demo (): ''' Test the barriers entry point ''' resp = client . get ( '/barriers/demo' ) dct = resp . json () assert dct [ 'project' ] == 'demo' contents = dct [ 'barriers' ] . split ( ' \\n ' ) assert len ( contents ) == 7 header = contents [ 0 ] . split ( ',' ) assert header [ 0 ] == 'ID' and header [ - 1 ] == 'comment' gates = { line . split ( ',' )[ 0 ] for line in contents [ 1 :] } assert gates == { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' } test_mapinfo_demo () Test the mapinfo entry point Source code in test/test_main.py 46 47 48 49 50 51 52 53 54 55 def test_mapinfo_demo (): ''' Test the mapinfo entry point ''' resp = client . get ( '/mapinfo/demo' ) dct = resp . json () info = json . loads ( dct [ 'mapinfo' ]) assert type ( info ) == dict assert info [ 'map_type' ] == 'StaticMap' assert info [ 'map_file' ] == 'Riverlands.png' test_targets_demo () Test the targets entry point with the demo project Source code in test/test_main.py 57 58 59 60 61 62 63 64 65 66 67 68 69 def test_targets_demo (): '''Test the targets entry point with the demo project''' resp = client . get ( '/targets/demo' ) dct = resp . json () assert dct [ 'project' ] == 'demo' contents = dct [ 'targets' ] . split ( ' \\n ' ) assert len ( contents ) == 3 header = contents [ 0 ] . split ( ',' ) assert header [ 0 ] == 'abbrev' and header [ - 1 ] == 'infra' targets = { line . split ( ',' )[ 0 ] for line in contents [ 1 :] } assert targets == { 'T1' , 'T2' } layout = dct [ 'layout' ] assert layout == 'T1 T2' test_unknown_project () Each of the paths should check for an unknown project name Source code in test/test_main.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def test_unknown_project (): ''' Each of the paths should check for an unknown project name ''' paths = [ '/html/foo/welcome.html' , '/barriers/foo' , '/mapinfo/foo' , '/targets/foo' , '/colnames/foo' , ] for p in paths : resp = client . get ( p ) assert resp . status_code == 404 test_unknown_files () Paths that fetch file should return 404 not found responses Source code in test/test_main.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def test_unknown_files (): ''' Paths that fetch file should return 404 not found responses ''' paths = [ '/html/demo/xxx.html' , '/map/demo/xxx.png' , ] for p in paths : resp = client . get ( p ) dct = resp . json () assert resp . status_code == 404 assert 'not found' in dct [ 'detail' ] Tests for optipass,py test_OP ( barriers , targets , colnames ) Test the OP constructor. Make an instance, make sure all instance vars set to defaults. Source code in test/test_optipass.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def test_OP ( barriers , targets , colnames ): ''' Test the OP constructor. Make an instance, make sure all instance vars set to defaults. ''' op = OptiPass ( barriers , targets , colnames , [], []) assert len ( op . barriers ) == 0 assert len ( op . passability ) == 0 assert len ( op . targets ) == 0 assert len ( op . mapping ) == 0 assert op . weighted == False assert op . input_frame is None assert op . paths is None assert op . summary is None assert op . matrix is None assert op . tmpdir is None test_OP_with_existing_data ( barriers , targets , colnames ) Test the OP constructor when a path to existing data is passed Source code in test/test_optipass.py 51 52 53 54 55 56 57 def test_OP_with_existing_data ( barriers , targets , colnames ): ''' Test the OP constructor when a path to existing data is passed ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [], [], tmpdir = p ) assert op . tmpdir == p test_region_and_target_names ( barriers , targets , colnames ) Verify region and target names Source code in test/test_optipass.py 59 60 61 62 63 64 65 66 67 68 def test_region_and_target_names ( barriers , targets , colnames ): ''' Verify region and target names ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) assert len ( op . barriers ) == 6 assert len ( op . passability ) == 6 assert len ( op . targets ) == 2 assert len ( op . mapping ) == 2 assert list ( op . mapping . index ) == list ( op . targets . index ) test_one_region_and_one_target ( barriers , targets , colnames ) Check barrier frame when only one region and one target is used Source code in test/test_optipass.py 70 71 72 73 74 75 76 77 78 79 def test_one_region_and_one_target ( barriers , targets , colnames ): ''' Check barrier frame when only one region and one target is used ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' ], [ 'T1' ]) assert len ( op . barriers ) == 4 assert len ( op . passability ) == 4 assert len ( op . targets ) == 1 assert len ( op . mapping ) == 1 assert list ( op . mapping . index ) == list ( op . targets . index ) test_one_target_input ( barriers , targets , colnames ) Make an input file for single target. Source code in test/test_optipass.py 81 82 83 84 85 86 87 88 89 90 91 92 def test_one_target_input ( barriers , targets , colnames ): ''' Make an input file for single target. ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ]) op . create_input_frame () df = op . input_frame assert len ( df ) == 6 assert list ( df . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_T1' , 'PRE_T1' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_T1' ] assert df . FOCUS . sum () == 6 assert df . ACTION . sum () == 0 assert df . COST . sum () == 590000 test_two_target_input ( barriers , targets , colnames ) Make an input file for two targets Source code in test/test_optipass.py 94 95 96 97 98 99 100 101 102 103 104 105 def test_two_target_input ( barriers , targets , colnames ): ''' Make an input file for two targets ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) op . create_input_frame () df = op . input_frame assert len ( df ) == 6 assert list ( df . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_T1' , 'HAB_T2' , 'PRE_T1' , 'PRE_T2' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_T1' , 'POST_T2' ] assert df . FOCUS . sum () == 6 assert df . ACTION . sum () == 0 assert df . COST . sum () == 590000 test_unweighted ( barriers , targets , colnames ) Make sure weights are initialized to 1s, one per target Source code in test/test_optipass.py 107 108 109 110 111 112 def test_unweighted ( barriers , targets , colnames ): ''' Make sure weights are initialized to 1s, one per target ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) assert op . weights == [ 1 , 1 ] test_weighted ( barriers , targets , colnames ) Make sure weights are initialized with specified settings Source code in test/test_optipass.py 114 115 116 117 118 119 def test_weighted ( barriers , targets , colnames ): ''' Make sure weights are initialized with specified settings ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], weights = [ 1 , 2 ]) assert op . weights == [ 1 , 2 ] test_paths ( barriers , targets , colnames ) Verify the paths downstream from gates Source code in test/test_optipass.py 121 122 123 124 125 126 127 128 129 130 131 def test_paths ( barriers , targets , colnames ): ''' Verify the paths downstream from gates ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ]) op . create_input_frame () op . create_paths () assert op . paths [ 'F' ] == [ 'F' , 'D' , 'A' ] assert op . paths [ 'C' ] == [ 'C' , 'B' , 'A' ] assert op . paths [ 'B' ] == [ 'B' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ] test_output_parser_one_target ( barriers , targets , colnames ) Parse an output file with only one target Source code in test/test_optipass.py 133 134 135 136 137 138 139 140 141 142 143 def test_output_parser_one_target ( barriers , targets , colnames ): ''' Parse an output file with only one target ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' / 'output_5.txt' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} op = OptiPass ( barriers , targets , colnames , [ 'Test1' ], [ 'T1' ]) op . parse_output ( p , cols ) assert len ( cols [ 'budget' ]) == 1 and round ( cols [ 'budget' ][ 0 ]) == 500000 assert len ( cols [ 'habitat' ]) == 1 and round ( cols [ 'habitat' ][ 0 ], 2 ) == 8.52 assert len ( cols [ 'gates' ]) == 1 and cols [ 'gates' ][ 0 ] == [ 'A' , 'B' , 'C' , 'F' ] test_output_parser_two_targets ( barriers , targets , colnames ) Parse an output file with two targets Source code in test/test_optipass.py 145 146 147 148 149 150 151 152 153 154 155 def test_output_parser_two_targets ( barriers , targets , colnames ): ''' Parse an output file with two targets ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' / 'output_5.txt' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) op . parse_output ( p , cols ) assert len ( cols [ 'budget' ]) == 1 and round ( cols [ 'budget' ][ 0 ]) == 500000 assert len ( cols [ 'habitat' ]) == 1 and round ( cols [ 'habitat' ][ 0 ], 3 ) == 32.936 assert len ( cols [ 'gates' ]) == 1 and cols [ 'gates' ][ 0 ] == [ 'A' , 'B' , 'C' , 'F' ] test_example_1 ( barriers , targets , colnames ) Collect all the results for Example 1 from the OptiPass User Manual. Source code in test/test_optipass.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def test_example_1 ( barriers , targets , colnames ): ''' Collect all the results for Example 1 from the OptiPass User Manual. ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500000 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected, # e.g. gate A is in the $400K and $500K budgets and D is never selected. assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'A' , b ]] == [ 400000 , 500000 ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'E' , b ]] == [ 100000 , 300000 ] assert list ( op . matrix [ 'count' ]) == [ 2 , 4 , 3 , 0 , 2 , 1 ] # number of times each gate is part of a solution test_example_4 ( barriers , targets , colnames ) Same as test_example_1, but using Example 4, which has two restoration targets. Source code in test/test_optipass.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def test_example_4 ( barriers , targets , colnames ): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500000 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'A' , b ]] == [ 400000 , 500000 ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'E' , b ]] == [ 100000 , 300000 ] assert list ( op . matrix [ 'count' ]) == [ 2 , 4 , 3 , 0 , 2 , 1 ] # number of times each gate is part of a solution test_potential_habitat_1 ( barriers , targets , colnames ) Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual (Box 9). Source code in test/test_optipass.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def test_potential_habitat_1 ( barriers , targets , colnames ): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual (Box 9). ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 # PTNL_HABITAT at $0 assert round ( m . wph [ 5 ], 3 ) == 8.520 # PTNL_HABITAT at $500K test_potential_habitat_4 ( barriers , targets , colnames ) Same as test_potential_habitat_1, but using Example 4, with two restoration targets weighted differently (Box 11) Source code in test/test_optipass.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def test_potential_habitat_4 ( barriers , targets , colnames ): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets weighted differently (Box 11) ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], weights = [ 3 , 1 ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # PTNL_HABITAT at $400K","title":"Tests"},{"location":"tests/#unit-tests","text":"Unit testing is done with pytest . To run all the tests, simply cd to the top level directory and type this shell command: $ pytest The tests are all in the tests directory: test_main.py has functions that test each of the paths defined in main.py test_optipass.py has functions that test the interface to OptiPass You can run one set of tests by including the file name in the shell command, e.g. $ pytest test/test_optipass.py","title":"Unit Tests"},{"location":"tests/#tests-for-mainpy","text":"","title":"Tests for main.py"},{"location":"tests/#test.test_main.test_projects","text":"Make sure the demo project is one of the projectes. Source code in test/test_main.py 14 15 16 17 18 19 20 def test_projects (): ''' Make sure the demo project is one of the projectes. ''' resp = client . get ( '/projects' ) lst = resp . json () assert 'demo' in lst","title":"test_projects"},{"location":"tests/#test.test_main.test_html_demo","text":"Fetch the welcome message for the demo project, look for key words Source code in test/test_main.py 22 23 24 25 26 27 28 29 30 def test_html_demo (): ''' Fetch the welcome message for the demo project, look for key words ''' resp = client . get ( '/html/demo/welcome.html' ) s = resp . json () assert s . count ( '<p>' ) == 11 assert s . count ( 'OptiPass' ) == 9 assert s . count ( 'FastAPI' ) == 1","title":"test_html_demo"},{"location":"tests/#test.test_main.test_barriers_demo","text":"Test the barriers entry point Source code in test/test_main.py 32 33 34 35 36 37 38 39 40 41 42 43 44 def test_barriers_demo (): ''' Test the barriers entry point ''' resp = client . get ( '/barriers/demo' ) dct = resp . json () assert dct [ 'project' ] == 'demo' contents = dct [ 'barriers' ] . split ( ' \\n ' ) assert len ( contents ) == 7 header = contents [ 0 ] . split ( ',' ) assert header [ 0 ] == 'ID' and header [ - 1 ] == 'comment' gates = { line . split ( ',' )[ 0 ] for line in contents [ 1 :] } assert gates == { 'A' , 'B' , 'C' , 'D' , 'E' , 'F' }","title":"test_barriers_demo"},{"location":"tests/#test.test_main.test_mapinfo_demo","text":"Test the mapinfo entry point Source code in test/test_main.py 46 47 48 49 50 51 52 53 54 55 def test_mapinfo_demo (): ''' Test the mapinfo entry point ''' resp = client . get ( '/mapinfo/demo' ) dct = resp . json () info = json . loads ( dct [ 'mapinfo' ]) assert type ( info ) == dict assert info [ 'map_type' ] == 'StaticMap' assert info [ 'map_file' ] == 'Riverlands.png'","title":"test_mapinfo_demo"},{"location":"tests/#test.test_main.test_targets_demo","text":"Test the targets entry point with the demo project Source code in test/test_main.py 57 58 59 60 61 62 63 64 65 66 67 68 69 def test_targets_demo (): '''Test the targets entry point with the demo project''' resp = client . get ( '/targets/demo' ) dct = resp . json () assert dct [ 'project' ] == 'demo' contents = dct [ 'targets' ] . split ( ' \\n ' ) assert len ( contents ) == 3 header = contents [ 0 ] . split ( ',' ) assert header [ 0 ] == 'abbrev' and header [ - 1 ] == 'infra' targets = { line . split ( ',' )[ 0 ] for line in contents [ 1 :] } assert targets == { 'T1' , 'T2' } layout = dct [ 'layout' ] assert layout == 'T1 T2'","title":"test_targets_demo"},{"location":"tests/#test.test_main.test_unknown_project","text":"Each of the paths should check for an unknown project name Source code in test/test_main.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def test_unknown_project (): ''' Each of the paths should check for an unknown project name ''' paths = [ '/html/foo/welcome.html' , '/barriers/foo' , '/mapinfo/foo' , '/targets/foo' , '/colnames/foo' , ] for p in paths : resp = client . get ( p ) assert resp . status_code == 404","title":"test_unknown_project"},{"location":"tests/#test.test_main.test_unknown_files","text":"Paths that fetch file should return 404 not found responses Source code in test/test_main.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def test_unknown_files (): ''' Paths that fetch file should return 404 not found responses ''' paths = [ '/html/demo/xxx.html' , '/map/demo/xxx.png' , ] for p in paths : resp = client . get ( p ) dct = resp . json () assert resp . status_code == 404 assert 'not found' in dct [ 'detail' ]","title":"test_unknown_files"},{"location":"tests/#tests-for-optipasspy","text":"","title":"Tests for optipass,py"},{"location":"tests/#test.test_optipass.test_OP","text":"Test the OP constructor. Make an instance, make sure all instance vars set to defaults. Source code in test/test_optipass.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def test_OP ( barriers , targets , colnames ): ''' Test the OP constructor. Make an instance, make sure all instance vars set to defaults. ''' op = OptiPass ( barriers , targets , colnames , [], []) assert len ( op . barriers ) == 0 assert len ( op . passability ) == 0 assert len ( op . targets ) == 0 assert len ( op . mapping ) == 0 assert op . weighted == False assert op . input_frame is None assert op . paths is None assert op . summary is None assert op . matrix is None assert op . tmpdir is None","title":"test_OP"},{"location":"tests/#test.test_optipass.test_OP_with_existing_data","text":"Test the OP constructor when a path to existing data is passed Source code in test/test_optipass.py 51 52 53 54 55 56 57 def test_OP_with_existing_data ( barriers , targets , colnames ): ''' Test the OP constructor when a path to existing data is passed ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [], [], tmpdir = p ) assert op . tmpdir == p","title":"test_OP_with_existing_data"},{"location":"tests/#test.test_optipass.test_region_and_target_names","text":"Verify region and target names Source code in test/test_optipass.py 59 60 61 62 63 64 65 66 67 68 def test_region_and_target_names ( barriers , targets , colnames ): ''' Verify region and target names ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) assert len ( op . barriers ) == 6 assert len ( op . passability ) == 6 assert len ( op . targets ) == 2 assert len ( op . mapping ) == 2 assert list ( op . mapping . index ) == list ( op . targets . index )","title":"test_region_and_target_names"},{"location":"tests/#test.test_optipass.test_one_region_and_one_target","text":"Check barrier frame when only one region and one target is used Source code in test/test_optipass.py 70 71 72 73 74 75 76 77 78 79 def test_one_region_and_one_target ( barriers , targets , colnames ): ''' Check barrier frame when only one region and one target is used ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' ], [ 'T1' ]) assert len ( op . barriers ) == 4 assert len ( op . passability ) == 4 assert len ( op . targets ) == 1 assert len ( op . mapping ) == 1 assert list ( op . mapping . index ) == list ( op . targets . index )","title":"test_one_region_and_one_target"},{"location":"tests/#test.test_optipass.test_one_target_input","text":"Make an input file for single target. Source code in test/test_optipass.py 81 82 83 84 85 86 87 88 89 90 91 92 def test_one_target_input ( barriers , targets , colnames ): ''' Make an input file for single target. ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ]) op . create_input_frame () df = op . input_frame assert len ( df ) == 6 assert list ( df . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_T1' , 'PRE_T1' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_T1' ] assert df . FOCUS . sum () == 6 assert df . ACTION . sum () == 0 assert df . COST . sum () == 590000","title":"test_one_target_input"},{"location":"tests/#test.test_optipass.test_two_target_input","text":"Make an input file for two targets Source code in test/test_optipass.py 94 95 96 97 98 99 100 101 102 103 104 105 def test_two_target_input ( barriers , targets , colnames ): ''' Make an input file for two targets ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) op . create_input_frame () df = op . input_frame assert len ( df ) == 6 assert list ( df . columns ) == [ 'ID' , 'REG' , 'FOCUS' , 'DSID' , 'HAB_T1' , 'HAB_T2' , 'PRE_T1' , 'PRE_T2' , 'NPROJ' , 'ACTION' , 'COST' , 'POST_T1' , 'POST_T2' ] assert df . FOCUS . sum () == 6 assert df . ACTION . sum () == 0 assert df . COST . sum () == 590000","title":"test_two_target_input"},{"location":"tests/#test.test_optipass.test_unweighted","text":"Make sure weights are initialized to 1s, one per target Source code in test/test_optipass.py 107 108 109 110 111 112 def test_unweighted ( barriers , targets , colnames ): ''' Make sure weights are initialized to 1s, one per target ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) assert op . weights == [ 1 , 1 ]","title":"test_unweighted"},{"location":"tests/#test.test_optipass.test_weighted","text":"Make sure weights are initialized with specified settings Source code in test/test_optipass.py 114 115 116 117 118 119 def test_weighted ( barriers , targets , colnames ): ''' Make sure weights are initialized with specified settings ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], weights = [ 1 , 2 ]) assert op . weights == [ 1 , 2 ]","title":"test_weighted"},{"location":"tests/#test.test_optipass.test_paths","text":"Verify the paths downstream from gates Source code in test/test_optipass.py 121 122 123 124 125 126 127 128 129 130 131 def test_paths ( barriers , targets , colnames ): ''' Verify the paths downstream from gates ''' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ]) op . create_input_frame () op . create_paths () assert op . paths [ 'F' ] == [ 'F' , 'D' , 'A' ] assert op . paths [ 'C' ] == [ 'C' , 'B' , 'A' ] assert op . paths [ 'B' ] == [ 'B' , 'A' ] assert op . paths [ 'A' ] == [ 'A' ]","title":"test_paths"},{"location":"tests/#test.test_optipass.test_output_parser_one_target","text":"Parse an output file with only one target Source code in test/test_optipass.py 133 134 135 136 137 138 139 140 141 142 143 def test_output_parser_one_target ( barriers , targets , colnames ): ''' Parse an output file with only one target ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' / 'output_5.txt' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} op = OptiPass ( barriers , targets , colnames , [ 'Test1' ], [ 'T1' ]) op . parse_output ( p , cols ) assert len ( cols [ 'budget' ]) == 1 and round ( cols [ 'budget' ][ 0 ]) == 500000 assert len ( cols [ 'habitat' ]) == 1 and round ( cols [ 'habitat' ][ 0 ], 2 ) == 8.52 assert len ( cols [ 'gates' ]) == 1 and cols [ 'gates' ][ 0 ] == [ 'A' , 'B' , 'C' , 'F' ]","title":"test_output_parser_one_target"},{"location":"tests/#test.test_optipass.test_output_parser_two_targets","text":"Parse an output file with two targets Source code in test/test_optipass.py 145 146 147 148 149 150 151 152 153 154 155 def test_output_parser_two_targets ( barriers , targets , colnames ): ''' Parse an output file with two targets ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' / 'output_5.txt' cols = { x : [] for x in [ 'budget' , 'habitat' , 'gates' ]} op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ]) op . parse_output ( p , cols ) assert len ( cols [ 'budget' ]) == 1 and round ( cols [ 'budget' ][ 0 ]) == 500000 assert len ( cols [ 'habitat' ]) == 1 and round ( cols [ 'habitat' ][ 0 ], 3 ) == 32.936 assert len ( cols [ 'gates' ]) == 1 and cols [ 'gates' ][ 0 ] == [ 'A' , 'B' , 'C' , 'F' ]","title":"test_output_parser_two_targets"},{"location":"tests/#test.test_optipass.test_example_1","text":"Collect all the results for Example 1 from the OptiPass User Manual. Source code in test/test_optipass.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 def test_example_1 ( barriers , targets , colnames ): ''' Collect all the results for Example 1 from the OptiPass User Manual. ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500000 assert round ( op . summary . habitat . sum (), 2 ) == 23.30 budget_cols = [ col for col in op . matrix . columns if isinstance ( col , int )] assert budget_cols == list ( op . summary . budget ) # these comprehensions make lists of budgets where a specified gate was selected, # e.g. gate A is in the $400K and $500K budgets and D is never selected. assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'A' , b ]] == [ 400000 , 500000 ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'E' , b ]] == [ 100000 , 300000 ] assert list ( op . matrix [ 'count' ]) == [ 2 , 4 , 3 , 0 , 2 , 1 ] # number of times each gate is part of a solution","title":"test_example_1"},{"location":"tests/#test.test_optipass.test_example_4","text":"Same as test_example_1, but using Example 4, which has two restoration targets. Source code in test/test_optipass.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def test_example_4 ( barriers , targets , colnames ): ''' Same as test_example_1, but using Example 4, which has two restoration targets. ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () assert type ( op . summary ) == pd . DataFrame assert len ( op . summary ) == 6 assert round ( op . summary . budget . sum ()) == 1500000 assert round ( op . summary . habitat . sum (), 2 ) == 95.21 # using two targets does not change the gate selections assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'A' , b ]] == [ 400000 , 500000 ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'D' , b ]] == [ ] assert [ b for b in op . matrix . columns if isinstance ( b , int ) and op . matrix . loc [ 'E' , b ]] == [ 100000 , 300000 ] assert list ( op . matrix [ 'count' ]) == [ 2 , 4 , 3 , 0 , 2 , 1 ] # number of times each gate is part of a solution","title":"test_example_4"},{"location":"tests/#test.test_optipass.test_potential_habitat_1","text":"Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual (Box 9). Source code in test/test_optipass.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def test_potential_habitat_1 ( barriers , targets , colnames ): ''' Test the method that computes potential habitat, using the results genearated for Example 1 in the OptiPass manual (Box 9). ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_1' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 1.238 # PTNL_HABITAT at $0 assert round ( m . wph [ 5 ], 3 ) == 8.520 # PTNL_HABITAT at $500K","title":"test_potential_habitat_1"},{"location":"tests/#test.test_optipass.test_potential_habitat_4","text":"Same as test_potential_habitat_1, but using Example 4, with two restoration targets weighted differently (Box 11) Source code in test/test_optipass.py 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def test_potential_habitat_4 ( barriers , targets , colnames ): ''' Same as test_potential_habitat_1, but using Example 4, with two restoration targets weighted differently (Box 11) ''' p = Path ( os . path . dirname ( __file__ )) / 'fixtures' / 'Example_4' op = OptiPass ( barriers , targets , colnames , [ 'Trident' , 'Red Fork' ], [ 'T1' , 'T2' ], weights = [ 3 , 1 ], tmpdir = p ) op . create_input_frame () op . create_paths () op . collect_results () m = op . summary assert len ( m ) == 6 assert 'T1' in m . columns and 'T2' in m . columns and 'wph' in m . columns assert round ( m . wph [ 0 ], 3 ) == 5.491 assert round ( m . wph [ 4 ], 3 ) == 21.084 # PTNL_HABITAT at $400K","title":"test_potential_habitat_4"}]}
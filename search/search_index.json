{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"REST Server for OptiPass OptiPass\u2122 is an application developed by Jesse O'Hanley at Ecotelligence\u00ae, LLC (https://www.ecotelligence.net/home/optipass). The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients (such as the one at https://github.com/conery/op-client) can run on any system, or even in a Docker container. Overview The server has two main roles: It manages tide gate data for one or more projects. Each data set is a CSV file where records describe tide gates and other barriers. Attributes include barrier names, locations, and so on. The file also has the attributes OptiPass uses: the cost to repair or replace a barrier, the upstream habitat impacted by the barrier, and the potential benefit of improving the barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers, and descriptions of potential benefits. The complete data set for the Oregon Coast, for example, is in a CSV file with over 1000 records and is 330KB. Each request to run OptiPass uses a small fraction of this data, so it makes sense to keep the data on the server and send short descriptions to the client. Example A common scenario for testing a FastAPI application is to launch Uvicorn (a Python-based web server) on the development system, passing it the name of the main function and specifying a port to listen to: $ uvicorn app.main:app --port 8001 Then to request data from the server, simply send an HTML GET request to that port. The response will be a JSON-encoded string that can easily be converted into a Python object. This request asks the server for the names of all the datasets it manages: $ curl localhost:8001/projects [\"demo\"] The repository includes a test data set named demo (based on the examples in the OptiPass manual). Others can be added simply by saving them in the static folder on the server (see Data ). Implementation The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : notes for developers static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in Modules . The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules. Deployment Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or on a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory ( OptiPass is not included with the repository ) add their data files to the static folder (see Data ) open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"REST Server for OptiPass"},{"location":"#rest-server-for-optipass","text":"OptiPass\u2122 is an application developed by Jesse O'Hanley at Ecotelligence\u00ae, LLC (https://www.ecotelligence.net/home/optipass). The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients (such as the one at https://github.com/conery/op-client) can run on any system, or even in a Docker container.","title":"REST Server for OptiPass"},{"location":"#overview","text":"The server has two main roles: It manages tide gate data for one or more projects. Each data set is a CSV file where records describe tide gates and other barriers. Attributes include barrier names, locations, and so on. The file also has the attributes OptiPass uses: the cost to repair or replace a barrier, the upstream habitat impacted by the barrier, and the potential benefit of improving the barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers, and descriptions of potential benefits. The complete data set for the Oregon Coast, for example, is in a CSV file with over 1000 records and is 330KB. Each request to run OptiPass uses a small fraction of this data, so it makes sense to keep the data on the server and send short descriptions to the client.","title":"Overview"},{"location":"#example","text":"A common scenario for testing a FastAPI application is to launch Uvicorn (a Python-based web server) on the development system, passing it the name of the main function and specifying a port to listen to: $ uvicorn app.main:app --port 8001 Then to request data from the server, simply send an HTML GET request to that port. The response will be a JSON-encoded string that can easily be converted into a Python object. This request asks the server for the names of all the datasets it manages: $ curl localhost:8001/projects [\"demo\"] The repository includes a test data set named demo (based on the examples in the OptiPass manual). Others can be added simply by saving them in the static folder on the server (see Data ).","title":"Example"},{"location":"#implementation","text":"The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : notes for developers static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in Modules . The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules.","title":"Implementation"},{"location":"#deployment","text":"Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or on a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory ( OptiPass is not included with the repository ) add their data files to the static folder (see Data ) open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"Deployment"},{"location":"data/","text":"Tidegate Data Files All of the data used by the optimizer is in a single CSV file. The file can have data on tide gates, culverts, or any obstacle encountered by migrating fish. We'll use the generic term \"barrier.\" A data file has one line for each barrier. The attributes (columns) define a barrier's ID, the ID of it's downstream neighbor, it's geographic name (typically a river system), and the costs and benefits of restoring the barrier. The web app looks for data files in the static directory. The repo has one data file, named test_wb.csv created using the example river system shown in the OptiPass user manual: BARID,REGION,DSID,HAB1,PRE1,POST1,HAB2,PRE2,POST2,COST A,OPM,NA,2.1,0.4,1.0,1.68,0.6,1.0,250 B,OPM,A,0.9,0.0,1.0,0.72,0.0,1.0,120 C,OPM,B,4.3,0.3,1.0,3.44,0.45,1.0,70 D,OPM,A,1.7,0.5,NA,1.36,0.75,NA,NA E,OPM,D,1.2,0.2,1.0,0.96,0.3,1.0,100 F,OPM,D,0.5,0.1,1.0,0.40,0.15,1.0,50 (the \"OPM\" in the REGION column stands for \"OptiPass Manual\"). The Python code for the web app refers to another data file, named workbook.csv , that is also expected to be in the static folder. This file has data from over 1,000 tide gates on the Oregon coast. It is not include in the repo. Eventually the names and locations of data files will be defined in a configuration file, and all the references to these two CSV files will be replaced with values taken from the configuration file.","title":"Data"},{"location":"data/#tidegate-data-files","text":"All of the data used by the optimizer is in a single CSV file. The file can have data on tide gates, culverts, or any obstacle encountered by migrating fish. We'll use the generic term \"barrier.\" A data file has one line for each barrier. The attributes (columns) define a barrier's ID, the ID of it's downstream neighbor, it's geographic name (typically a river system), and the costs and benefits of restoring the barrier. The web app looks for data files in the static directory. The repo has one data file, named test_wb.csv created using the example river system shown in the OptiPass user manual: BARID,REGION,DSID,HAB1,PRE1,POST1,HAB2,PRE2,POST2,COST A,OPM,NA,2.1,0.4,1.0,1.68,0.6,1.0,250 B,OPM,A,0.9,0.0,1.0,0.72,0.0,1.0,120 C,OPM,B,4.3,0.3,1.0,3.44,0.45,1.0,70 D,OPM,A,1.7,0.5,NA,1.36,0.75,NA,NA E,OPM,D,1.2,0.2,1.0,0.96,0.3,1.0,100 F,OPM,D,0.5,0.1,1.0,0.40,0.15,1.0,50 (the \"OPM\" in the REGION column stands for \"OptiPass Manual\"). The Python code for the web app refers to another data file, named workbook.csv , that is also expected to be in the static folder. This file has data from over 1,000 tide gates on the Oregon coast. It is not include in the repo. Eventually the names and locations of data files will be defined in a configuration file, and all the references to these two CSV files will be replaced with values taken from the configuration file.","title":"Tidegate Data Files"},{"location":"install/","text":"Installation The first step is to set up the execution environment. If you are installing this code on system that will run other Python applications we recommend creating and activating a new virtual environment with venv . You will need Python 3.10 or later. If you are setting up a VM dedicated to just this application you can simply install Python 3.10 or later and add the libraries to the global environment. Log in to your VM with an administrator account. Obtain a copy of the repo, either by cloning it or downloading the .zip file. Open a terminal and navigate to the directory. You should see the following structure: tidegates \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 README.md \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 bin/ \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 static/ \u251c\u2500\u2500 templates/ \u2514\u2500\u2500 tidegates/ Use PIP to install all the dependencies: > python -m pip install -r requirements.txt Move a copy of the OptiPass command line application to the bin directory. After you do this that directory should have the exe file for OptiPass and some Python scripts that are part of the repo: bin \u251c\u2500\u2500 OptiPassMain.exe \u2514\u2500\u2500 sanitize.py","title":"Installation"},{"location":"install/#installation","text":"The first step is to set up the execution environment. If you are installing this code on system that will run other Python applications we recommend creating and activating a new virtual environment with venv . You will need Python 3.10 or later. If you are setting up a VM dedicated to just this application you can simply install Python 3.10 or later and add the libraries to the global environment. Log in to your VM with an administrator account. Obtain a copy of the repo, either by cloning it or downloading the .zip file. Open a terminal and navigate to the directory. You should see the following structure: tidegates \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 README.md \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 bin/ \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 static/ \u251c\u2500\u2500 templates/ \u2514\u2500\u2500 tidegates/ Use PIP to install all the dependencies: > python -m pip install -r requirements.txt Move a copy of the OptiPass command line application to the bin directory. After you do this that directory should have the exe file for OptiPass and some Python scripts that are part of the repo: bin \u251c\u2500\u2500 OptiPassMain.exe \u2514\u2500\u2500 sanitize.py","title":"Installation"},{"location":"modules/","text":"Modules The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one for running ( optipass.py ) that provides an abstract interface for running OptiPass app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py main.py Initialization Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE , TARGETS , TARGET_FILE , COLNAMES , COLNAME_FILE BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' global project_names , region_names project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f } read_csv_file Read a CSV file from one of the static subdirectories. Parameters: project \u2013 the project name area \u2013 the data area (barriers, targets, colnames) fn \u2013 the name of the file within the data area Returns: \u2013 the contents of the file, as a single string Source code in app/main.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def read_csv_file ( project , area , fn ): ''' Read a CSV file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn with open ( p ) as f : return f . read () . rstrip () projects Respond to GET requests of the form /projects . Returns: \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 72 73 74 75 76 77 78 79 80 @app . get ( \"/projects\" ) async def projects (): ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names regions Respond to GET requests of the form /regions/P where P is a project name. Returns: \u2013 a list of regions (river names) for a project, taken from the second column of the barrier file for the project. Source code in app/main.py 85 86 87 88 89 90 91 92 93 @app . get ( \"/regions/ {project} \" ) async def regions ( project : str ): ''' Respond to GET requests of the form `/regions/P` where P is a project name. Returns: a list of regions (river names) for a project, taken from the second column of the barrier file for the project. ''' return { 'project' : project , 'regions' : region_names . get ( project )} barriers Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers } targets Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers } colnames Respond to GET requests of the form /colnames/P where P is a project name. Returns: \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ): ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' if project not in project_names : return None cname_dir = Path ( COLNAMES ) / project if not cname_dir . is_dir (): return None cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} if not cname_dir . is_dir (): return None alts = list ( cname_dir . iterdir ()) if len ( alts ) != 1 : return None alt_name = alts [ 0 ] if not alt_name . is_dir (): return None cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames } optipass A GET request of the form /optipass/P?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (path to target and barrier files) regions ( str ) \u2013 comma-separated string of region names targets ( str ) \u2013 comma-separated string of 2-letter target IDs weights ( str | None , default: None ) \u2013 comma-separated list of ints, one for each target (optional) bmin ( int ) \u2013 first budget value bcount ( int ) \u2013 number of budgets ( i.e. number of times to run OptiPass) bdelta ( int ) \u2013 distance between budget values ( i.e. step size) colnames ( str | None , default: None ) \u2013 climate scenario, either current or future (optional) Returns: \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : str , targets : str , bmin : int , bcount : int , bdelta : int , colnames : str | None = None , weights : str | None = None ): ''' A GET request of the form `/optipass/P?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (path to target and barrier files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs weights: comma-separated list of ints, one for each target (optional) bmin: first budget value bcount: number of budgets (_i.e._ number of times to run OptiPass) bdelta: distance between budget values (_i.e._ step size) colnames: climate scenario, either `current` or `future` (optional) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' try : assert project in project_names , f 'unknown project: { project } ' barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE target_file = target_file_name ( project , climate ) assert target_file , f 'no targets in project \" { project } \" for climate: \" { climate } \"' region_list = regions . split ( ',' ) assert all ( r in region_names [ project ] for r in region_list ), f 'unknown region in { regions } ' target_list = targets . split ( ',' ) token = run_optipass ( barrier_file , target_file , region_list , target_list , weights , bmin , bcount , bdelta ) status = 'ok' except AssertionError as err : status = 'fail' token = str ( err ) return { 'status' : status , 'token' : token } tables Respond to a GET request of the form /tables/T where T is a token returned by an earlier call to optipass . Returns: \u2013 a dictionary with a status code and two output tables Source code in app/main.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @app . get ( \"/tables/ {token} \" ) async def tables ( token : str ): ''' Respond to a GET request of the form `/tables/T` where T is a token returned by an earlier call to `optipass`. Returns: a dictionary with a status code and two output tables ''' try : with open ( Path ( OUTPUTS ) / token / 'matrix.txt' ) as f : matrix = f . read () with open ( Path ( OUTPUTS ) / token / 'summary.txt' ) as f : summary = f . read () result = { 'status' : 'ok' , 'matrix' : matrix , 'summary' : summary } except Exception as err : result = { 'status' : 'fail' , 'message' : f 'error reading results for { token } : { str ( err ) } ' } return result","title":"Modules"},{"location":"modules/#modules","text":"The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one for running ( optipass.py ) that provides an abstract interface for running OptiPass app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py","title":"Modules"},{"location":"modules/#mainpy","text":"","title":"main.py"},{"location":"modules/#initialization","text":"Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE , TARGETS , TARGET_FILE , COLNAMES , COLNAME_FILE BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' global project_names , region_names project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f }","title":"Initialization"},{"location":"modules/#read_csv_file","text":"Read a CSV file from one of the static subdirectories. Parameters: project \u2013 the project name area \u2013 the data area (barriers, targets, colnames) fn \u2013 the name of the file within the data area Returns: \u2013 the contents of the file, as a single string Source code in app/main.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def read_csv_file ( project , area , fn ): ''' Read a CSV file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn with open ( p ) as f : return f . read () . rstrip ()","title":"read_csv_file"},{"location":"modules/#projects","text":"Respond to GET requests of the form /projects . Returns: \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 72 73 74 75 76 77 78 79 80 @app . get ( \"/projects\" ) async def projects (): ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names","title":"projects"},{"location":"modules/#regions","text":"Respond to GET requests of the form /regions/P where P is a project name. Returns: \u2013 a list of regions (river names) for a project, taken from the second column of the barrier file for the project. Source code in app/main.py 85 86 87 88 89 90 91 92 93 @app . get ( \"/regions/ {project} \" ) async def regions ( project : str ): ''' Respond to GET requests of the form `/regions/P` where P is a project name. Returns: a list of regions (river names) for a project, taken from the second column of the barrier file for the project. ''' return { 'project' : project , 'regions' : region_names . get ( project )}","title":"regions"},{"location":"modules/#barriers","text":"Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers }","title":"barriers"},{"location":"modules/#targets","text":"Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers }","title":"targets"},{"location":"modules/#colnames","text":"Respond to GET requests of the form /colnames/P where P is a project name. Returns: \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ): ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' if project not in project_names : return None cname_dir = Path ( COLNAMES ) / project if not cname_dir . is_dir (): return None cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} if not cname_dir . is_dir (): return None alts = list ( cname_dir . iterdir ()) if len ( alts ) != 1 : return None alt_name = alts [ 0 ] if not alt_name . is_dir (): return None cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames }","title":"colnames"},{"location":"modules/#optipass","text":"A GET request of the form /optipass/P?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (path to target and barrier files) regions ( str ) \u2013 comma-separated string of region names targets ( str ) \u2013 comma-separated string of 2-letter target IDs weights ( str | None , default: None ) \u2013 comma-separated list of ints, one for each target (optional) bmin ( int ) \u2013 first budget value bcount ( int ) \u2013 number of budgets ( i.e. number of times to run OptiPass) bdelta ( int ) \u2013 distance between budget values ( i.e. step size) colnames ( str | None , default: None ) \u2013 climate scenario, either current or future (optional) Returns: \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : str , targets : str , bmin : int , bcount : int , bdelta : int , colnames : str | None = None , weights : str | None = None ): ''' A GET request of the form `/optipass/P?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (path to target and barrier files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs weights: comma-separated list of ints, one for each target (optional) bmin: first budget value bcount: number of budgets (_i.e._ number of times to run OptiPass) bdelta: distance between budget values (_i.e._ step size) colnames: climate scenario, either `current` or `future` (optional) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' try : assert project in project_names , f 'unknown project: { project } ' barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE target_file = target_file_name ( project , climate ) assert target_file , f 'no targets in project \" { project } \" for climate: \" { climate } \"' region_list = regions . split ( ',' ) assert all ( r in region_names [ project ] for r in region_list ), f 'unknown region in { regions } ' target_list = targets . split ( ',' ) token = run_optipass ( barrier_file , target_file , region_list , target_list , weights , bmin , bcount , bdelta ) status = 'ok' except AssertionError as err : status = 'fail' token = str ( err ) return { 'status' : status , 'token' : token }","title":"optipass"},{"location":"modules/#tables","text":"Respond to a GET request of the form /tables/T where T is a token returned by an earlier call to optipass . Returns: \u2013 a dictionary with a status code and two output tables Source code in app/main.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @app . get ( \"/tables/ {token} \" ) async def tables ( token : str ): ''' Respond to a GET request of the form `/tables/T` where T is a token returned by an earlier call to `optipass`. Returns: a dictionary with a status code and two output tables ''' try : with open ( Path ( OUTPUTS ) / token / 'matrix.txt' ) as f : matrix = f . read () with open ( Path ( OUTPUTS ) / token / 'summary.txt' ) as f : summary = f . read () result = { 'status' : 'ok' , 'matrix' : matrix , 'summary' : summary } except Exception as err : result = { 'status' : 'fail' , 'message' : f 'error reading results for { token } : { str ( err ) } ' } return result","title":"tables"},{"location":"tests/","text":"Integration Tests Integration tests are implemented in the top level application ( main.py ). To perorm a test, run main with options that specify which type of test to run and where to find the data for the test. See the documentation for main.py for details and examples. Unit Tests If a module has unit tests they are included in the source file. Tests are defined at the end of the file, in a class that has a name that starts with Test . For example, project.py defines a class named Project, and at the end of the file is another class named TestProject. A test class defines a series of static methods that have names beginning with test . These methods are run in order. To run tests for a module, open a terminal window and cd to the top level folder. Then type a command that runs pytest , including the name of the module to test: $ pytest src/tidegates/project.py It's also possible to run all the tests with a single shell command: $ pytest src/tidegates/*.py","title":"Tests"},{"location":"tests/#integration-tests","text":"Integration tests are implemented in the top level application ( main.py ). To perorm a test, run main with options that specify which type of test to run and where to find the data for the test. See the documentation for main.py for details and examples.","title":"Integration Tests"},{"location":"tests/#unit-tests","text":"If a module has unit tests they are included in the source file. Tests are defined at the end of the file, in a class that has a name that starts with Test . For example, project.py defines a class named Project, and at the end of the file is another class named TestProject. A test class defines a series of static methods that have names beginning with test . These methods are run in order. To run tests for a module, open a terminal window and cd to the top level folder. Then type a command that runs pytest , including the name of the module to test: $ pytest src/tidegates/project.py It's also possible to run all the tests with a single shell command: $ pytest src/tidegates/*.py","title":"Unit Tests"}]}
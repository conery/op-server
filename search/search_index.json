{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"REST Server for OptiPass OptiPass\u2122 is an application developed by Jesse O'Hanley at Ecotelligence\u00ae, LLC (https://www.ecotelligence.net/home/optipass). The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients (such as the one at https://github.com/conery/op-client) can run on any system, or even in a Docker container. Overview The server has two main roles: It manages tide gate data for one or more projects. Each data set is a CSV file where records describe tide gates and other barriers. Attributes include barrier names, locations, and so on. The file also has the attributes OptiPass uses: the cost to repair or replace a barrier, the upstream habitat impacted by the barrier, and the potential benefit of improving the barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers, and descriptions of potential benefits. The complete data set for the Oregon Coast, for example, is in a CSV file with over 1000 records and is 330KB. Each request to run OptiPass uses a small fraction of this data, so it makes sense to keep the data on the server and send short descriptions to the client. Example A common scenario for testing a FastAPI application is to launch Uvicorn (a Python-based web server) on the development system, passing it the name of the main function and specifying a port to listen to: $ uvicorn app.main:app --port 8001 Then to request data from the server, simply send an HTML GET request to that port. The response will be a JSON-encoded string that can easily be converted into a Python object. This request asks the server for the names of all the datasets it manages: $ curl localhost:8001/projects [\"demo\"] The repository includes a test data set named demo (based on the examples in the OptiPass manual). Others can be added simply by saving them in the static folder on the server (see Data ). Implementation The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : notes for developers static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in Modules . The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules. Deployment Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or on a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory ( OptiPass is not included with the repository ) add their data files to the static folder (see Data ) open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"REST Server for OptiPass"},{"location":"#rest-server-for-optipass","text":"OptiPass\u2122 is an application developed by Jesse O'Hanley at Ecotelligence\u00ae, LLC (https://www.ecotelligence.net/home/optipass). The application is written in Visual C++ and runs only in a Microsoft Windows environment. To make it more accessible to web applications we developed this REST server. While the server needs to run on a Windows system, clients (such as the one at https://github.com/conery/op-client) can run on any system, or even in a Docker container.","title":"REST Server for OptiPass"},{"location":"#overview","text":"The server has two main roles: It manages tide gate data for one or more projects. Each data set is a CSV file where records describe tide gates and other barriers. Attributes include barrier names, locations, and so on. The file also has the attributes OptiPass uses: the cost to repair or replace a barrier, the upstream habitat impacted by the barrier, and the potential benefit of improving the barrier. The server provides an API for running OptiPass. A request to run OptiPass will include the IDs of barriers to include and the budget levels to use in order to generate ROI curves to show potential benefits from increasing budget levels. It would be possible to assign these roles to different applications -- e.g. have separate servers for the data and OptiPass -- but we decided to combine them in order to minimize web traffic. A client simply needs to know the names and locations of barriers, and descriptions of potential benefits. The complete data set for the Oregon Coast, for example, is in a CSV file with over 1000 records and is 330KB. Each request to run OptiPass uses a small fraction of this data, so it makes sense to keep the data on the server and send short descriptions to the client.","title":"Overview"},{"location":"#example","text":"A common scenario for testing a FastAPI application is to launch Uvicorn (a Python-based web server) on the development system, passing it the name of the main function and specifying a port to listen to: $ uvicorn app.main:app --port 8001 Then to request data from the server, simply send an HTML GET request to that port. The response will be a JSON-encoded string that can easily be converted into a Python object. This request asks the server for the names of all the datasets it manages: $ curl localhost:8001/projects [\"demo\"] The repository includes a test data set named demo (based on the examples in the OptiPass manual). Others can be added simply by saving them in the static folder on the server (see Data ).","title":"Example"},{"location":"#implementation","text":"The server is written entirely in Python, using FastAPI to manage requests. The top level directories in the GitHub repository are: app : the main FastAPI application bin : a folder for OptiPass.exe and other executables docs : notes for developers static : CSV files for barrier data and restoration target descriptions test : unit tests Detailed documentation for the Python code in the app folder can be found in Modules . The test descriptions in Unit Tests are a good place to find examples of how to call functions in the modules.","title":"Implementation"},{"location":"#deployment","text":"Developers who want to deploy the server using their own data need to do the following (described in more detail in Installation ): set up a server that runs Microsoft Windows; this can be a stand-alone Windows system on a networked PC, or on a virtual machine at Amazon Web Services or another cloud service clone the repository (this can be done with a single PIP command) install the command line version of OptiPass in the bin directory ( OptiPass is not included with the repository ) add their data files to the static folder (see Data ) open a PowerShell window and type the command that starts the server (recommended) set up Nginx, Apache, or some other fully-featured web server and configure it as a reverse proxy","title":"Deployment"},{"location":"data/","text":"Data Files All of the data managed by the server is in the static folder. The three types of data are barrier files, target descriptions, and column name mappings, each in a separate subfolder. Projects Inside each subfolder there are additional folders for each data set. The name of the folder is the project name . The GitHub repository includes a project named demo that is based on the examples in the OptiPass user manual (https://www.ecotelligence.net/home/optipass). Each additional data set will go in its own set of folders. As an example, the server for tide gates on the Oregon Coast has a project named oregon , which leads to this structure: static \u251c\u2500\u2500 barriers \u2502 \u251c\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 oregon \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 colnames \u2502 \u251c\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 oregon \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 targets \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 oregon \u2514\u2500\u2500 ... Barriers A barrier file is a table (in CSV format) with one row for each tide gate, culvert, or other object that can restrict the flow of water in a river system. The first three columns are: BARID , a unique barrier ID REGION , the name of the region the barrier is in (typically the name of a river system) DSID , the ID of the nearest downstream barrier (OptiPass requires each barrier to have at most one downstream barrier) The last two columns are COST , the dollar amount for replacing or repairing the barrier (any units can be used, as long as they are all the same) NPROJ , an integer that is either 0 or 1 in our data sets. 1 means the barrier should be included an any analysis of the region it belongs to, 0 means the barrier should not included ( e.g. this column might be 0 if a barrier is a dam that cannot be replaced or if a landowner does not want it in the data set). The middle rows of the table has columns that describe restoration targets, described in the next section. Targets Each time we run OpitPass we give it a budget value. It will return the IDs of a set of barriers that provide the most benefit for that budget. The barriers it chooses are based on our goals. If the goal is to improve fish migration, the benefits will be an increase in the amount of river habitat in the region upstream from a barrier. If the goal is to protect farmland from flooding, the benefits will be an increase in the amount of acreage protected. The general term for these goals is restoration target , or simply \"target\". A file named targets.csv contains descriptions of targets that can be used by the server. The file has one row per target. The columns in the file are: abbrev , a unique two-letter target ID (which will also be used in the column mapping table, described in the next section) long , a string that is displayed in the GUI shown by a server to allow users to choose targets to use short , a shorter target name that will be used in tables and plots label , a string with units to use on axes in plots infra , either True or False, depending on whether this target is for infrastructure such as buildings or farm land (True) or fish migration (False) Column Maps In order to use targets we need to quantify the benefits of repairing or replacing barriers. We do this by including three columns in the barrier table for each target: The habitat column is the size of the area immediately upstream from a barrier. For fish migration targets, habitat could be expressed as the number of river miles between a barrier and the barrier(s) immediately upstream. If the goal is to protect farmland, habitat could be measured in acres. The passability of a barrier is a measure of how much habitat is available upstream from the barrier. It is represented by a number between 0 (no habitat is available upstream) to 1 (all habitat upstream is reachable). The pre-mitigation passability column in the table represents the current passability, before any restoration is done. The third column is another passability value, the post-mitigation passability , which is the potential passability after replacing or repairing the barrier. A data set can have any number of targets. Each target is a separate group of three columns in the table. A column map table connects column descriptions shown to users (from the targets table) to quantified benefits (in the barriers table). The table has one row for each target. The first column is the target ID (the two-letter abbreviation from the targets table). The remaining columns are the names of columns in the barriers table that have the habitat and passability values for the target. Example The small river system used as an example in the OptiPass user manual has six barriers, named A through F . A is at the mouth of the river, and the rest are all upstream from A : At each node $p^0$ is the pre-mitigation passability, $c$ is the cost to repair the barrier, and $h$ is the habitat (in river kilometers). In this example barrier D is a natural barrier that cannot be replaced, so there is no cost associated with this node. The figure above shows values for only one target. Later in the manual there is an example that has a second target. We put the data for both targets in our barrier file. Columns HAB1 , PRE1 , and POST1 are for the first target, and HAB2 , PRE2 , and POST2 are for the second target. The final data set is in static/barriers/demo/barriers.csv (shown here as a table to make it more readable): BARID REGION DSID HAB1 PRE1 POST1 HAB2 PRE2 POST2 COST NPROJ A Test1 NA 2.1 0.4 1.0 1.68 0.6 1.0 250 1 B Test1 A 0.9 0.0 1.0 0.72 0.0 1.0 120 1 C Test1 B 4.3 0.3 1.0 3.44 0.45 1.0 70 1 D Test1 A 1.7 0.5 NA 1.36 0.75 NA NA 0 E Test1 D 1.2 0.2 1.0 0.96 0.3 1.0 100 1 F Test1 D 0.5 0.1 1.0 0.40 0.15 1.0 50 1 Barrier D is the natural barrier that can't be replaced. The NPROJ column is 0, and it has no cost or post-mitigation values since they aren't used. The target file for this data set assigns the IDs T1 and T2 to the two targets. For this simple example we just gave them short names and left the other fields blank. The target file in static/targets/demo/targets.csv looks like this: abbrev long short label infra T1 Target1 T2 Target2 Finally, to connect the target descriptions in the target file to the quantified benefits in the barrier file we have the following column name mapping ( static/colnames/demo/colnames.csv ): abbrev habitat prepass postpass T1 HAB1 PRE1 POST1 T2 HAB2 PRE2 POST2 This tells the server to find data for target T1 in columns HAB1 , PRE1 , and POST , and the data for target T2 are in HAB2 , PRE2 , and POST2 . Running OptiPass with the Example Data To run OptiPass with the sample data, send a GET request to the server, with the following options: use \"demo\" as the project name use \"Test1\" as the region name use \"T1\", \"T2\", or both as the target name If testing on the local machine the request will look something like this: $ curl localhost:8000/optipass?project=demo&regions=Test1&targets=T1,T2&... where the remaining arguments specify budget levels. A Note About Scaled Data A real data set, such as the barrier file for the Oregon Coast, can have a combination of fish passage targets and infrastructure targets. The units for fish passage are river miles (or kilometers or any other linear measure). However, the units for the other targets can be quite different: acres or hectares or other measures of land area for farm land, or miles for roads, or number of buildings. In order to consider all of these kinds of data in a single optimization run, the units need to be scaled before they are saved in the habitat columns in the barrier file. To allow modelers to save the original unscaled data, the data file formats have additional columns not described above: there are four columns for each target, where the additional column is for the unscaled data in its original units; this column is not used by OptiPass, but is there so it can be used for other purposes there is an optional column in the colnames table to hold the name of the unscaled data","title":"Data Files"},{"location":"data/#data-files","text":"All of the data managed by the server is in the static folder. The three types of data are barrier files, target descriptions, and column name mappings, each in a separate subfolder.","title":"Data Files"},{"location":"data/#projects","text":"Inside each subfolder there are additional folders for each data set. The name of the folder is the project name . The GitHub repository includes a project named demo that is based on the examples in the OptiPass user manual (https://www.ecotelligence.net/home/optipass). Each additional data set will go in its own set of folders. As an example, the server for tide gates on the Oregon Coast has a project named oregon , which leads to this structure: static \u251c\u2500\u2500 barriers \u2502 \u251c\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 oregon \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 colnames \u2502 \u251c\u2500\u2500 demo \u2502 \u2502 \u2514\u2500\u2500 ... \u2502 \u2514\u2500\u2500 oregon \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 targets \u251c\u2500\u2500 demo \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 oregon \u2514\u2500\u2500 ...","title":"Projects"},{"location":"data/#barriers","text":"A barrier file is a table (in CSV format) with one row for each tide gate, culvert, or other object that can restrict the flow of water in a river system. The first three columns are: BARID , a unique barrier ID REGION , the name of the region the barrier is in (typically the name of a river system) DSID , the ID of the nearest downstream barrier (OptiPass requires each barrier to have at most one downstream barrier) The last two columns are COST , the dollar amount for replacing or repairing the barrier (any units can be used, as long as they are all the same) NPROJ , an integer that is either 0 or 1 in our data sets. 1 means the barrier should be included an any analysis of the region it belongs to, 0 means the barrier should not included ( e.g. this column might be 0 if a barrier is a dam that cannot be replaced or if a landowner does not want it in the data set). The middle rows of the table has columns that describe restoration targets, described in the next section.","title":"Barriers"},{"location":"data/#targets","text":"Each time we run OpitPass we give it a budget value. It will return the IDs of a set of barriers that provide the most benefit for that budget. The barriers it chooses are based on our goals. If the goal is to improve fish migration, the benefits will be an increase in the amount of river habitat in the region upstream from a barrier. If the goal is to protect farmland from flooding, the benefits will be an increase in the amount of acreage protected. The general term for these goals is restoration target , or simply \"target\". A file named targets.csv contains descriptions of targets that can be used by the server. The file has one row per target. The columns in the file are: abbrev , a unique two-letter target ID (which will also be used in the column mapping table, described in the next section) long , a string that is displayed in the GUI shown by a server to allow users to choose targets to use short , a shorter target name that will be used in tables and plots label , a string with units to use on axes in plots infra , either True or False, depending on whether this target is for infrastructure such as buildings or farm land (True) or fish migration (False)","title":"Targets"},{"location":"data/#column-maps","text":"In order to use targets we need to quantify the benefits of repairing or replacing barriers. We do this by including three columns in the barrier table for each target: The habitat column is the size of the area immediately upstream from a barrier. For fish migration targets, habitat could be expressed as the number of river miles between a barrier and the barrier(s) immediately upstream. If the goal is to protect farmland, habitat could be measured in acres. The passability of a barrier is a measure of how much habitat is available upstream from the barrier. It is represented by a number between 0 (no habitat is available upstream) to 1 (all habitat upstream is reachable). The pre-mitigation passability column in the table represents the current passability, before any restoration is done. The third column is another passability value, the post-mitigation passability , which is the potential passability after replacing or repairing the barrier. A data set can have any number of targets. Each target is a separate group of three columns in the table. A column map table connects column descriptions shown to users (from the targets table) to quantified benefits (in the barriers table). The table has one row for each target. The first column is the target ID (the two-letter abbreviation from the targets table). The remaining columns are the names of columns in the barriers table that have the habitat and passability values for the target.","title":"Column Maps"},{"location":"data/#example","text":"The small river system used as an example in the OptiPass user manual has six barriers, named A through F . A is at the mouth of the river, and the rest are all upstream from A : At each node $p^0$ is the pre-mitigation passability, $c$ is the cost to repair the barrier, and $h$ is the habitat (in river kilometers). In this example barrier D is a natural barrier that cannot be replaced, so there is no cost associated with this node. The figure above shows values for only one target. Later in the manual there is an example that has a second target. We put the data for both targets in our barrier file. Columns HAB1 , PRE1 , and POST1 are for the first target, and HAB2 , PRE2 , and POST2 are for the second target. The final data set is in static/barriers/demo/barriers.csv (shown here as a table to make it more readable): BARID REGION DSID HAB1 PRE1 POST1 HAB2 PRE2 POST2 COST NPROJ A Test1 NA 2.1 0.4 1.0 1.68 0.6 1.0 250 1 B Test1 A 0.9 0.0 1.0 0.72 0.0 1.0 120 1 C Test1 B 4.3 0.3 1.0 3.44 0.45 1.0 70 1 D Test1 A 1.7 0.5 NA 1.36 0.75 NA NA 0 E Test1 D 1.2 0.2 1.0 0.96 0.3 1.0 100 1 F Test1 D 0.5 0.1 1.0 0.40 0.15 1.0 50 1 Barrier D is the natural barrier that can't be replaced. The NPROJ column is 0, and it has no cost or post-mitigation values since they aren't used. The target file for this data set assigns the IDs T1 and T2 to the two targets. For this simple example we just gave them short names and left the other fields blank. The target file in static/targets/demo/targets.csv looks like this: abbrev long short label infra T1 Target1 T2 Target2 Finally, to connect the target descriptions in the target file to the quantified benefits in the barrier file we have the following column name mapping ( static/colnames/demo/colnames.csv ): abbrev habitat prepass postpass T1 HAB1 PRE1 POST1 T2 HAB2 PRE2 POST2 This tells the server to find data for target T1 in columns HAB1 , PRE1 , and POST , and the data for target T2 are in HAB2 , PRE2 , and POST2 .","title":"Example"},{"location":"data/#running-optipass-with-the-example-data","text":"To run OptiPass with the sample data, send a GET request to the server, with the following options: use \"demo\" as the project name use \"Test1\" as the region name use \"T1\", \"T2\", or both as the target name If testing on the local machine the request will look something like this: $ curl localhost:8000/optipass?project=demo&regions=Test1&targets=T1,T2&... where the remaining arguments specify budget levels.","title":"Running OptiPass with the Example Data"},{"location":"data/#a-note-about-scaled-data","text":"A real data set, such as the barrier file for the Oregon Coast, can have a combination of fish passage targets and infrastructure targets. The units for fish passage are river miles (or kilometers or any other linear measure). However, the units for the other targets can be quite different: acres or hectares or other measures of land area for farm land, or miles for roads, or number of buildings. In order to consider all of these kinds of data in a single optimization run, the units need to be scaled before they are saved in the habitat columns in the barrier file. To allow modelers to save the original unscaled data, the data file formats have additional columns not described above: there are four columns for each target, where the additional column is for the unscaled data in its original units; this column is not used by OptiPass, but is there so it can be used for other purposes there is an optional column in the colnames table to hold the name of the unscaled data","title":"A Note About Scaled Data"},{"location":"data/#_1","text":"","title":""},{"location":"install/","text":"Installation TBD","title":"Installation"},{"location":"install/#installation","text":"TBD","title":"Installation"},{"location":"modules/","text":"Modules The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one for running ( optipass.py ) that provides an abstract interface for running OptiPass app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py main.py Initialization Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE , TARGETS , TARGET_FILE , COLNAMES , COLNAME_FILE BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' global project_names , region_names project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f } read_csv_file Read a CSV file from one of the static subdirectories. Parameters: project \u2013 the project name area \u2013 the data area (barriers, targets, colnames) fn \u2013 the name of the file within the data area Returns: \u2013 the contents of the file, as a single string Source code in app/main.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def read_csv_file ( project , area , fn ): ''' Read a CSV file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn with open ( p ) as f : return f . read () . rstrip () projects Respond to GET requests of the form /projects . Returns: \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 72 73 74 75 76 77 78 79 80 @app . get ( \"/projects\" ) async def projects (): ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names regions Respond to GET requests of the form /regions/P where P is a project name. Returns: \u2013 a list of regions (river names) for a project, taken from the second column of the barrier file for the project. Source code in app/main.py 85 86 87 88 89 90 91 92 93 @app . get ( \"/regions/ {project} \" ) async def regions ( project : str ): ''' Respond to GET requests of the form `/regions/P` where P is a project name. Returns: a list of regions (river names) for a project, taken from the second column of the barrier file for the project. ''' return { 'project' : project , 'regions' : region_names . get ( project )} barriers Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers } targets Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers } colnames Respond to GET requests of the form /colnames/P where P is a project name. Returns: \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ): ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' if project not in project_names : return None cname_dir = Path ( COLNAMES ) / project if not cname_dir . is_dir (): return None cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} if not cname_dir . is_dir (): return None alts = list ( cname_dir . iterdir ()) if len ( alts ) != 1 : return None alt_name = alts [ 0 ] if not alt_name . is_dir (): return None cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames } optipass A GET request of the form /optipass/P?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (path to target and barrier files) regions ( str ) \u2013 comma-separated string of region names targets ( str ) \u2013 comma-separated string of 2-letter target IDs weights ( str | None , default: None ) \u2013 comma-separated list of ints, one for each target (optional) bmin ( int ) \u2013 first budget value bcount ( int ) \u2013 number of budgets ( i.e. number of times to run OptiPass) bdelta ( int ) \u2013 distance between budget values ( i.e. step size) colnames ( str | None , default: None ) \u2013 climate scenario, either current or future (optional) Returns: \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : str , targets : str , bmin : int , bcount : int , bdelta : int , colnames : str | None = None , weights : str | None = None ): ''' A GET request of the form `/optipass/P?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (path to target and barrier files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs weights: comma-separated list of ints, one for each target (optional) bmin: first budget value bcount: number of budgets (_i.e._ number of times to run OptiPass) bdelta: distance between budget values (_i.e._ step size) colnames: climate scenario, either `current` or `future` (optional) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' try : assert project in project_names , f 'unknown project: { project } ' barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE target_file = target_file_name ( project , climate ) assert target_file , f 'no targets in project \" { project } \" for climate: \" { climate } \"' region_list = regions . split ( ',' ) assert all ( r in region_names [ project ] for r in region_list ), f 'unknown region in { regions } ' target_list = targets . split ( ',' ) token = run_optipass ( barrier_file , target_file , region_list , target_list , weights , bmin , bcount , bdelta ) status = 'ok' except AssertionError as err : status = 'fail' token = str ( err ) return { 'status' : status , 'token' : token } tables Respond to a GET request of the form /tables/T where T is a token returned by an earlier call to optipass . Returns: \u2013 a dictionary with a status code and two output tables Source code in app/main.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @app . get ( \"/tables/ {token} \" ) async def tables ( token : str ): ''' Respond to a GET request of the form `/tables/T` where T is a token returned by an earlier call to `optipass`. Returns: a dictionary with a status code and two output tables ''' try : with open ( Path ( OUTPUTS ) / token / 'matrix.txt' ) as f : matrix = f . read () with open ( Path ( OUTPUTS ) / token / 'summary.txt' ) as f : summary = f . read () result = { 'status' : 'ok' , 'matrix' : matrix , 'summary' : summary } except Exception as err : result = { 'status' : 'fail' , 'message' : f 'error reading results for { token } : { str ( err ) } ' } return result optipass.py TBD","title":"Modules"},{"location":"modules/#modules","text":"The source code is in a folder named app . There are only two source files in the folder, one ( main.py ) for the FastAPI application and one for running ( optipass.py ) that provides an abstract interface for running OptiPass app \u251c\u2500\u2500 main.py \u2514\u2500\u2500 optipass.py","title":"Modules"},{"location":"modules/#mainpy","text":"","title":"main.py"},{"location":"modules/#initialization","text":"Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. Source code in app/main.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def init (): ''' Define global variables used in the rest of the application: paths to static data and names of static data files, a list of names of projects, a dictionary of region names for each project. ''' global BARRIERS , BARRIER_FILE , TARGETS , TARGET_FILE , COLNAMES , COLNAME_FILE BARRIERS = 'static/barriers' BARRIER_FILE = 'barriers.csv' TARGETS = 'static/targets' TARGET_FILE = 'targets.csv' COLNAMES = 'static/colnames' COLNAME_FILE = 'colnames.csv' global project_names , region_names project_names = [ p . stem for p in Path ( BARRIERS ) . iterdir ()] region_names = { } for project in project_names : barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE with open ( barrier_file ) as f : f . readline () # skip the header region_names [ project ] = { rec . split ( ',' )[ 1 ] for rec in f }","title":"Initialization"},{"location":"modules/#read_csv_file","text":"Read a CSV file from one of the static subdirectories. Parameters: project \u2013 the project name area \u2013 the data area (barriers, targets, colnames) fn \u2013 the name of the file within the data area Returns: \u2013 the contents of the file, as a single string Source code in app/main.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def read_csv_file ( project , area , fn ): ''' Read a CSV file from one of the static subdirectories. Args: project: the project name area: the data area (barriers, targets, colnames) fn: the name of the file within the data area Returns: the contents of the file, as a single string ''' p = Path ( area ) / project / fn with open ( p ) as f : return f . read () . rstrip ()","title":"read_csv_file"},{"location":"modules/#projects","text":"Respond to GET requests of the form /projects . Returns: \u2013 a list of the names of the projects (datasets) managed by the server. Source code in app/main.py 72 73 74 75 76 77 78 79 80 @app . get ( \"/projects\" ) async def projects (): ''' Respond to GET requests of the form `/projects`. Returns: a list of the names of the projects (datasets) managed by the server. ''' return project_names","title":"projects"},{"location":"modules/#regions","text":"Respond to GET requests of the form /regions/P where P is a project name. Returns: \u2013 a list of regions (river names) for a project, taken from the second column of the barrier file for the project. Source code in app/main.py 85 86 87 88 89 90 91 92 93 @app . get ( \"/regions/ {project} \" ) async def regions ( project : str ): ''' Respond to GET requests of the form `/regions/P` where P is a project name. Returns: a list of regions (river names) for a project, taken from the second column of the barrier file for the project. ''' return { 'project' : project , 'regions' : region_names . get ( project )}","title":"regions"},{"location":"modules/#barriers","text":"Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers }","title":"barriers"},{"location":"modules/#targets","text":"Respond to GET requests of the form /barriers/P where P is a project name. Returns: \u2013 the barrier data file for a project, as one long string. Source code in app/main.py 98 99 100 101 102 103 104 105 106 107 108 109 110 @app . get ( \"/barriers/ {project} \" ) async def barriers ( project : str ): ''' Respond to GET requests of the form `/barriers/P` where P is a project name. Returns: the barrier data file for a project, as one long string. ''' if project in project_names : barriers = read_csv_file ( project , BARRIERS , BARRIER_FILE ) else : barriers = None return { 'project' : project , 'barriers' : barriers }","title":"targets"},{"location":"modules/#colnames","text":"Respond to GET requests of the form /colnames/P where P is a project name. Returns: \u2013 a dictionary with two entries, the name of the mapping and the names of the colname files Source code in app/main.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @app . get ( \"/colnames/ {project} \" ) async def colnames ( project : str ): ''' Respond to GET requests of the form `/colnames/P` where P is a project name. Returns: a dictionary with two entries, the name of the mapping and the names of the colname files ''' if project not in project_names : return None cname_dir = Path ( COLNAMES ) / project if not cname_dir . is_dir (): return None cname_file = cname_dir / COLNAME_FILE if cname_file . is_file (): return { 'name' : None , 'files' : [ COLNAME_FILE ]} if not cname_dir . is_dir (): return None alts = list ( cname_dir . iterdir ()) if len ( alts ) != 1 : return None alt_name = alts [ 0 ] if not alt_name . is_dir (): return None cnames = [ p . stem for p in alt_name . iterdir () if p . suffix == '.csv' ] return { 'name' : alt_name . name , 'files' : cnames }","title":"colnames"},{"location":"modules/#optipass","text":"A GET request of the form /optipass/P?ARGS runs OptiPass using the parameter values passed in the URL. Parameters: project ( str ) \u2013 the name of the project (path to target and barrier files) regions ( str ) \u2013 comma-separated string of region names targets ( str ) \u2013 comma-separated string of 2-letter target IDs weights ( str | None , default: None ) \u2013 comma-separated list of ints, one for each target (optional) bmin ( int ) \u2013 first budget value bcount ( int ) \u2013 number of budgets ( i.e. number of times to run OptiPass) bdelta ( int ) \u2013 distance between budget values ( i.e. step size) colnames ( str | None , default: None ) \u2013 climate scenario, either current or future (optional) Returns: \u2013 a dictionary with a status indicator and a token that can be used to fetch results. Source code in app/main.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 @app . get ( \"/optipass/ {project} \" ) async def optipass ( project : str , regions : str , targets : str , bmin : int , bcount : int , bdelta : int , colnames : str | None = None , weights : str | None = None ): ''' A GET request of the form `/optipass/P?ARGS` runs OptiPass using the parameter values passed in the URL. Args: project: the name of the project (path to target and barrier files) regions: comma-separated string of region names targets: comma-separated string of 2-letter target IDs weights: comma-separated list of ints, one for each target (optional) bmin: first budget value bcount: number of budgets (_i.e._ number of times to run OptiPass) bdelta: distance between budget values (_i.e._ step size) colnames: climate scenario, either `current` or `future` (optional) Returns: a dictionary with a status indicator and a token that can be used to fetch results. ''' try : assert project in project_names , f 'unknown project: { project } ' barrier_file = Path ( BARRIERS ) / project / BARRIER_FILE target_file = target_file_name ( project , climate ) assert target_file , f 'no targets in project \" { project } \" for climate: \" { climate } \"' region_list = regions . split ( ',' ) assert all ( r in region_names [ project ] for r in region_list ), f 'unknown region in { regions } ' target_list = targets . split ( ',' ) token = run_optipass ( barrier_file , target_file , region_list , target_list , weights , bmin , bcount , bdelta ) status = 'ok' except AssertionError as err : status = 'fail' token = str ( err ) return { 'status' : status , 'token' : token }","title":"optipass"},{"location":"modules/#tables","text":"Respond to a GET request of the form /tables/T where T is a token returned by an earlier call to optipass . Returns: \u2013 a dictionary with a status code and two output tables Source code in app/main.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 @app . get ( \"/tables/ {token} \" ) async def tables ( token : str ): ''' Respond to a GET request of the form `/tables/T` where T is a token returned by an earlier call to `optipass`. Returns: a dictionary with a status code and two output tables ''' try : with open ( Path ( OUTPUTS ) / token / 'matrix.txt' ) as f : matrix = f . read () with open ( Path ( OUTPUTS ) / token / 'summary.txt' ) as f : summary = f . read () result = { 'status' : 'ok' , 'matrix' : matrix , 'summary' : summary } except Exception as err : result = { 'status' : 'fail' , 'message' : f 'error reading results for { token } : { str ( err ) } ' } return result","title":"tables"},{"location":"modules/#optipasspy","text":"TBD","title":"optipass.py"},{"location":"tests/","text":"Integration Tests TBD Unit Tests TBD","title":"Tests"},{"location":"tests/#integration-tests","text":"TBD","title":"Integration Tests"},{"location":"tests/#unit-tests","text":"TBD","title":"Unit Tests"}]}